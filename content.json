{"meta":{"title":"Syraer's Blog","subtitle":"您好。世界！","description":"一枚小菜鸡~","author":"Syraer","url":"http://www.zzugo.ayxyj.cn","root":"/"},"pages":[{"title":"categories","date":"2020-11-08T07:43:09.000Z","updated":"2020-11-08T07:44:19.916Z","comments":true,"path":"categories/index.html","permalink":"http://www.zzugo.ayxyj.cn/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2020-11-08T07:56:08.000Z","updated":"2020-11-08T12:15:36.430Z","comments":true,"path":"friends/index.html","permalink":"http://www.zzugo.ayxyj.cn/friends/index.html","excerpt":"","text":""},{"title":"gallerys","date":"2020-11-08T12:13:21.482Z","updated":"2020-11-08T12:13:21.481Z","comments":true,"path":"gallerys/index.html","permalink":"http://www.zzugo.ayxyj.cn/gallerys/index.html","excerpt":"","text":"ablums:[ [“https://s1.ax1x.com/2020/11/08/BosrNj.jpg&quot;,&quot;test1&quot;], [“https://s1.ax1x.com/2020/11/08/BosfDU.jpg&quot;,&quot;test2&quot;], [“https://s1.ax1x.com/2020/11/08/Bos5E4.jpg&quot;,&quot;test3&quot;]]"},{"title":"tags","date":"2020-11-08T07:44:59.000Z","updated":"2020-11-08T07:47:15.261Z","comments":true,"path":"tags/index.html","permalink":"http://www.zzugo.ayxyj.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Docker Registry - 搭建本地仓库并测试","slug":"docker_的私有registry","date":"2020-11-23T06:24:15.000Z","updated":"2020-11-24T03:24:25.000Z","comments":true,"path":"2020/11/23/docker_的私有registry/","link":"","permalink":"http://www.zzugo.ayxyj.cn/2020/11/23/docker_%E7%9A%84%E7%A7%81%E6%9C%89registry/","excerpt":"","text":"搭建一个私有的docker registry找一台docker host，然后运行 1docker run -d -v /opt/registry:/var/lib/registry -p 5000:5000 --restart=always --name registry registry:2 docker registry 绑定了到本地的80端口。 接下来我们配置DNS server，假如我们这台运行registry的机器地址是192.168.99.100, 然后我们找到上次配置gitlab ci的那个dns container 执行 1docker exec -it dns-server &#x2F;bin&#x2F;sh 添加一条新的记录 1234&#x2F; # more &#x2F;etc&#x2F;dnsmasqhosts192.168.211.10 gitlab.example.com192.168.99.100 registry.example.com&#x2F; # 然后重启container 1docker restart dns-server 最后我们去gitlab-ci服务器，ping一下 12345678910[vagrant@gitlab-ci ~]$ ping registry.example.comPING registry.example.com (192.168.99.100) 56(84) bytes of data.64 bytes from registry.example.com (192.168.99.100): icmp_seq&#x3D;1 ttl&#x3D;63 time&#x3D;0.395 ms64 bytes from registry.example.com (192.168.99.100): icmp_seq&#x3D;2 ttl&#x3D;63 time&#x3D;0.537 ms64 bytes from registry.example.com (192.168.99.100): icmp_seq&#x3D;3 ttl&#x3D;63 time&#x3D;0.683 ms^C--- registry.example.com ping statistics ---3 packets transmitted, 3 received, 0% packet loss, time 2003msrtt min&#x2F;avg&#x2F;max&#x2F;mdev &#x3D; 0.395&#x2F;0.538&#x2F;0.683&#x2F;0.119 ms[vagrant@gitlab-ci ~]$ 成功。 测试在gitlab-ci服务器上，编辑 创建一个文件 1sudo vim &#x2F;etc&#x2F;docker&#x2F;daemon.json 然后写入内容： 123[vagrant@gitlab-ci ~]$ sudo more &#x2F;etc&#x2F;docker&#x2F;daemon.json&#123; &quot;insecure-registries&quot;:[&quot;registry.example.com:5000&quot;] &#125;[vagrant@gitlab-ci ~]$ 从docker hub拉取一个busybox，然后打一个tag 12docker pull busyboxdocker tag busybox registry.example.com:5000&#x2F;busybox 然后push到我们的私有registry里 12345[vagrant@gitlab-ci ~]$ docker push registry.example.com:5000&#x2F;busyboxThe push refers to repository [registry.example.com:5000&#x2F;busybox]c5183829c43c: Pushedlatest: digest: sha256:c7b0a24019b0e6eda714ec0fa137ad42bc44a754d9cea17d14fba3a80ccc1ee4 size: 527[vagrant@gitlab-ci ~]$ 成功。","categories":[{"name":"Docker","slug":"Docker","permalink":"http://www.zzugo.ayxyj.cn/categories/Docker/"},{"name":"Registry","slug":"Docker/Registry","permalink":"http://www.zzugo.ayxyj.cn/categories/Docker/Registry/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://www.zzugo.ayxyj.cn/tags/Docker/"},{"name":"Registry","slug":"Registry","permalink":"http://www.zzugo.ayxyj.cn/tags/Registry/"}]},{"title":"Docker Portainer - 安装并远程连接docker-WebUI","slug":"docker-portainer","date":"2020-11-22T02:31:23.000Z","updated":"2020-11-24T03:20:24.000Z","comments":true,"path":"2020/11/22/docker-portainer/","link":"","permalink":"http://www.zzugo.ayxyj.cn/2020/11/22/docker-portainer/","excerpt":"","text":"Centos7远程访问系统中的docker-WebUI工具Portainer首先获取portainer image 1docker pull portainer/portainer 新建一个卷（portainer_data）来存Portainer数据 12345docker volume create portainer_datadocker run -d -p 9000:9000 -p 8000:8000 --name portainer --restart always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer #第二种本地存储docker run -d --restart=always -p 9000:9000 -v /root/portainer:/data -v /var/run/docker.sock:/var/run/docker.sock --name dev-portainer portainer/portainer 修改将要被远程连接的客户机的docker.service 文件开通docker的远程管理： 12vim /lib/systemd/system/docker.serviceExecStart=/usr/bin/dockerd -H unix:///var/run/docker.sock -H tcp://0.0.0.0:2375 重启客户机docker 12systemctl daemon-reload systemctl restart docker 关闭客户机防火墙 1234567查看防火墙状态： systemctl status firewalld.service #绿的running表示防火墙开启执行关闭命令： systemctl stop firewalld.service再次执行查看防火墙命令：systemctl status firewalld.service执行开机禁用防火墙自启命令 ： systemctl disable firewalld.service 查看端口信息 12ss -ntpl#存在2375即可访问","categories":[{"name":"Docker","slug":"Docker","permalink":"http://www.zzugo.ayxyj.cn/categories/Docker/"},{"name":"Portainer","slug":"Docker/Portainer","permalink":"http://www.zzugo.ayxyj.cn/categories/Docker/Portainer/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://www.zzugo.ayxyj.cn/tags/Docker/"},{"name":"Portainer","slug":"Portainer","permalink":"http://www.zzugo.ayxyj.cn/tags/Portainer/"}]},{"title":"Hyperledger Fabric - 01 - 安装并测试网络","slug":"fabric","date":"2020-11-22T02:31:23.000Z","updated":"2020-11-25T10:28:58.000Z","comments":true,"path":"2020/11/22/fabric/","link":"","permalink":"http://www.zzugo.ayxyj.cn/2020/11/22/fabric/","excerpt":"","text":"Hyperledger Fabric 搭建并测试一、环境准备 系统工具 版本 备注 CentOS 7 Docker 18.09.4 参考：Centps7安装docker Docker-compose 1.25.0 参考下方 GO 1.13.4 参考：CentOS7下载Go 解压配置环境变量即可 123456#安装docker-compose#方式一：curl -L https://github.com/docker/compose/releases/download/1.25.0-rc1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose sudo chmod +x /usr/local/bin/docker-compose#方式二：pip install -U docker-compose==1.23.2 二、安装fabric2.x首先，自行下载fabric源码git clone，将下载的fabric包解压出来，进入到$&#123;HOME&#125;/fabric/scripts脚本目录进行安装![1](./fabric/1 .png) 下载过程比较漫长，因为采用的是docker镜像容器进行安装，需要下载所需要的镜像，我这里面拉取了所有的镜像，很多暂时不用（2.x不支持kafka,zookeeper） 脚本执行结束后，可以看到相关镜像等其他信息，如果存在没有拉取完的镜像，就在执行一边。 通过docker查看拉取的镜像信息docker image ls -a 执行完如上图，另外在scripts目录下会多出来一个fabric-samples目录 三、启动test-network测试网络12cd /fabric-samples/test-networknetwork.sh up 如下图，表示启动成功，已启动一个orderer节点和两个peer节点。 可以查看本地启动的docker container 存在测试网络启动的oder和peer 12docker ps -a #查看启动的containerdocker container ls -a #查看启动的container 四、使用测试网络 创建channel，使用network.sh脚本创建来创建一个连接org1和org2组织并加入他们peer的通道，命令如下： 1./network.sh createChannel 如上图，创建成功（默认通道名为mychannel）。 也可以带上channel标签，命令如下（-c channelName）： 1./network.sh createChannel -c channel1 如果要在一个步骤中启动网络并创建频道，可以同时使用up和create channel模式： 1./network.sh up createChannel 在通道上启动链码。 使用network.sh创建通道之后，可以使用以下命令在通道上启动链码（默认使用go语言）： 1./network.sh deployCC 可以指定语言，加-l ，比如用java，命令如下： 1./network.sh deployCC -l java 如图，启动成功： 与网络互动 网络启动之后，可以使用peer cli客户端去操作网络，可以通过cli客户端去调用部署智能合约，更新通道，或者安装和部署新的智能合约。 首先确保操作目录为test-network目录。使用以下命令将二进制文件添加到cli路径： 1export PATH=$&#123;PWD&#125;/../bin:$&#123;PWD&#125;:$PATH 还需要设置FABRIC_CFG_PATH路径指向fabric-samples中的core.yaml文件，命令如下： 1export FABRIC_CFG_PATH=$PWD/../config/ 设置允许org1操作peer cli的环境变量： 123456# Environment variables for Org1export CORE_PEER_TLS_ENABLED=trueexport CORE_PEER_LOCALMSPID=&quot;Org1MSP&quot;export CORE_PEER_TLS_ROOTCERT_FILE=$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crtexport CORE_PEER_ADDRESS=localhost:7051export CORE_PEER_MSPCONFIGPATH=$&#123;PWD&#125;/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp 如上，CORE_PEER_TLS_ROOTCERT_FILE和CORE_PEER_MSPCONFIGPATH环境变量指向organizations文件夹中的org1的加密文件。 使用以下命令获取汽车资产列表： 1peer chaincode query -C mychannel -n fabcar -c &#x27;&#123;&quot;Args&quot;:[&quot;queryAllCars&quot;]&#125;&#x27; 五、关闭网络1./network.sh down 启动过程详解 ./network.sh为两个peer节点和一个order节点创建了证书和密钥，默认情况下，脚本会利用在organizations/cryptogen文件夹下的加密工具。 脚本利用configtxgen工具创建了系统的创世块，它使用configtx/configtx.yaml文件来创建创世块，并存储在system-genesis-block文件夹中。 当上述两步完成之后，./network.sh会启动网络，脚本利用在docker文件夹下的docker-compose-test-net.yaml文件创建peer和orderer节点。 如果使用了createChannel子命令，脚本还会运行script文件夹下的createChannel.sh脚本来创建所需要的channel，脚本会用peer命令来创建channel，加入两个组织。 如果运行了deployCC命令，脚本会在所有peers上运行script下的deployCC.sh脚本来安装fabcar chaincode，在chaincode的定义被提交到channel之后，peer命令会调用init函数来初始化chaincode，并将所需的数据放入chaincode中。 注：下图是fabric简化交易过程 六、标志并启动网络（ca为网络的标志）1./network.sh up -ca","categories":[{"name":"Blockchain","slug":"Blockchain","permalink":"http://www.zzugo.ayxyj.cn/categories/Blockchain/"},{"name":"Hyperledger Fabric","slug":"Blockchain/Hyperledger-Fabric","permalink":"http://www.zzugo.ayxyj.cn/categories/Blockchain/Hyperledger-Fabric/"}],"tags":[{"name":"Blockchain","slug":"Blockchain","permalink":"http://www.zzugo.ayxyj.cn/tags/Blockchain/"},{"name":"Hyperledger Fabric","slug":"Hyperledger-Fabric","permalink":"http://www.zzugo.ayxyj.cn/tags/Hyperledger-Fabric/"}]},{"title":"Solidity - 02 - 基本语法","slug":"solidity-02","date":"2020-11-18T04:36:42.000Z","updated":"2020-11-19T12:52:30.000Z","comments":true,"path":"2020/11/18/solidity-02/","link":"","permalink":"http://www.zzugo.ayxyj.cn/2020/11/18/solidity-02/","excerpt":"","text":"元素的可见性private 修饰的函数为私有的，只有合约内部可以调用 Public修饰的函数为共有的，合约内外都可以调用 public/private 可以修饰状态变量 状态变量默认是私有的 123456789101112131415161718192021222324252627282930pragma solidity ^0.4.24;contract Test &#123; //状态变量 //类型不匹配时需要显示转换类型 //返回值需要使用returns描述 //public/private 可以修饰状态变量 //状态变量默认是私有的 uint256 public ui256 = 100; int8 private i10 = -10; //private 修饰的函数为私有的，只有合约内部可以调用 function add() private view returns(uint256) &#123; return ui256 + uint256(i10); &#125; function isEqueal() public view returns(bool) &#123; return ui256 == uint256(i10); &#125; //Public修饰的函数为共有的，合约内外都可以调用 function Add() public view returns(uint256)&#123; return add(); &#125;&#125; View，Constant，Pure介绍 ==//在constant/view 修饰函数的函数中，如果去修改了状态变量，编译器不会报错，但是赋值不会成功(坑！！！！）== 12345678910111213141516171819202122232425262728293031323334353637383940414243pragma solidity ^0.4.24;contract Test &#123; //状态变量 //类型不匹配时需要显示转换类型 //返回值需要使用returns描述 //public/private 可以修饰状态变量 //状态变量默认是私有的 uint256 public ui = 100; int8 private i10 = 10; // 1. 如果函数中没有用到状态变量：（既没有读也没有写），就修饰为pure // 2. 如果读了，但是没写，修饰为view、constant // 3. 如果写了，那么不修饰即可 function add() public constant returns(uint256) &#123; return ui + uint256(i10); &#125; function test() public pure returns(string) &#123; return &quot;hello&quot;; &#125; function setValue(uint256 num) public &#123; ui = num; &#125; //在constant/view 修饰函数的函数中，如果去修改了状态变量，编译器不会报错，但是赋值不会成功(坑！！！！） function setValue1(uint256 num) public constant &#123; ui = num; &#125; function isEqueal() public view returns(bool) &#123; return ui == uint256(i10); &#125;&#125; payable关键字1234567891011121314151617181920212223pragma solidity ^0.4.24;contract Test &#123; string public str ; //修饰为payable的函数才可以接收转账 //不指定payable无法接收 function test1(string src) public payable &#123; str = src; &#125; function test2(string src) public &#123; str = src; &#125; function getbalance() public view returns(uint256) &#123; //this代表当前合约本身 //balance方法，获取当前合约的余额 return this.balance; &#125;&#125; 地址获取余额balance123456789101112131415161718192021222324252627282930313233343536pragma solidity ^0.4.24;contract Test &#123; address public addr1 = 0x0014723a09acff6d2a60dcdf7aa4aff308fddc160c; //地址address类型本质上是一个160位的数字 //可以进行加减，需要强制转换 function add() public view returns(uint160) &#123; return uint160(addr1) + 10; &#125; //1. 匿名函数：没有函数名，没有参数，没有返回值的函数，就是匿名函数 //2. 当调用一个不存在的方法时，合约会默认的去调用匿名函数 //3. 匿名函数一般用来给合约转账，因为费用低 function () public payable &#123; &#125; function getBalance() public view returns(uint256) &#123; return addr1.balance; &#125; function getContractBalance() public view returns(uint256) &#123; //this代表当前合约本身 //balance方法，获取当前合约的余额 return address(this).balance; &#125; &#125; 地址转账12345678910111213141516171819202122232425262728293031323334353637383940pragma solidity ^0.4.24;contract Test &#123; address public addr0 = 0x00ca35b7d915458ef540ade6068dfe2f44e8fa733c; address public addr1 = 0x0014723a09acff6d2a60dcdf7aa4aff308fddc160c; //1. 匿名函数：没有函数名，没有参数，没有返回值的函数，就是匿名函数 //2. 当调用一个不存在的方法时，合约会默认的去调用匿名函数 //3. 匿名函数一般用来给合约转账，因为费用低 function () public payable &#123; &#125; function getBalance() public view returns(uint256) &#123; return addr1.balance; &#125; function getContractBalance() public view returns(uint256) &#123; return address(this).balance; &#125; //由合约向addr1 转账10以太币 function transfer() public &#123; //1. 转账的时候单位是wei //2. 1 ether = 10 ^18 wei （10的18次方） //3. 向谁转钱，就用谁调用tranfer函数 //4. 花费的是合约的钱 //5. 如果金额不足，transfer函数会抛出异常 addr1.transfer(10 * 10 **18); &#125; //send转账与tranfer使用方式一致，但是如果转账金额不足，不会抛出异常，而是会返回false function sendTest() public &#123; addr1.send(10 * 10 **18); &#125;&#125; bytes1：内置的固定长度的字节数组123456789101112131415161718192021222324pragma solidity ^0.4.24;contract Test &#123; bytes1 b1 =&quot;h&quot;; bytes20 b10 = &quot;helloworld&quot;; function getLen() public view returns(uint256) &#123; return b10.length; &#125; function setValue() private pure &#123; //1. 固定长度数组可以通过下标访问 //2. 只能读取，不能写 //b10[0] = v; &#125; //3. 存储的时候是ascii值存储 function getValue(uint256 i) public view returns(byte) &#123; return b10[i]; &#125;&#125; bytes动态字节数组 可以不分空间，直接进行字符串赋值，会自动分配空间 如果未分配过空间，使用下标访问会访问越界报错 可以设置长度，自动分配对应空间，并且初始化为0 可以通过下标进行数据修改 支持push操作，在bytes最后面追加元素 注意的坑： 旧版本的remix可以直接在remix中使用”helloworld”形式给bytes赋值，新版本不允许，必须使用0x格式 例如，如果函数类型为：byte b1, 那么赋值时需要输入的格式为： “h”（旧版本）, 0x68(新版本) 123456789101112131415161718192021222324252627282930313233343536373839pragma solidity ^0.4.24;contract Test &#123; bytes public name; function getLen() public view returns(uint256) &#123; return name.length; &#125; //1. 可以不分空间，直接进行字符串赋值，会自动分配空间 function setValue(bytes input) public &#123; name = input; &#125; //2. 如果未分配过空间，使用下标访问会访问越界报错 function getByIndex(uint256 i) public view returns(byte) &#123; return name[i]; &#125; //3. 可以设置长度，自动分配对应空间，并且初始化为0 function setLen(uint256 len) public &#123; name.length = len; &#125; //4.可以通过下标进行数据修改 function setValue2(uint256 i) public &#123; name[i] = &#x27;h&#x27;; &#125; //5. 支持push操作，在bytes最后面追加元素 function pushData() public &#123; name.push(&#x27;h&#x27;); &#125; &#125; string 动态尺寸的UTF-8编码字符串，是特殊的可变字节数组 引用类型 不支持下标索引 不支持length、push方法 可以修改(需通过bytes转换) 12345678910111213141516171819202122pragma solidity ^0.4.24;contract Test &#123; string public name = &quot;lily&quot;; function setName() public &#123; bytes(name)[0] = &quot;L&quot;; &#125; function getLength() public view returns(uint256) &#123; return bytes(name).length; &#125; function setLength(uint256 i) public &#123; bytes(name).length = i; bytes(name)[i - 1] = &#x27;H&#x27;; &#125; &#125; storageVsMemory关键字1234567891011121314151617181920212223242526272829303132333435363738394041424344454647pragma solidity ^0.4.24;contract Test &#123; string public name = &quot;lily&quot;; uint256 public num = 10; function call1() public &#123; setName(name); &#125; //对于引用类型数据，作为函数参数时，默认是memory类型（值传递） //function setName(string input) private &#123; function setName(string memory input) private &#123; num = 20; bytes(input)[0] = &quot;L&quot;; &#125; function call2() public &#123; setName2(name); &#125; //2. 如果想引用传递，那么需要明确指定为stroage类型 function setName2(string storage input) private &#123; num = 30; bytes(input)[0] = &quot;L&quot;; &#125; //如果局部变量是string，数组，结构体类型数据，默认情况下是storage类型 function localTest() public &#123; //string tmp = name; string storage tmp = name; num = 40; bytes(tmp)[0] = &quot;L&quot;; &#125; function localTest1() public &#123; //也可以明确设置为memory类型 string memory tmp = name; num = 50; bytes(tmp)[0] = &quot;L&quot;; &#125;&#125; byte1BytesString相互转换1234567891011121314151617181920212223242526272829303132333435363738pragma solidity ^0.4.24;contract Test &#123; bytes10 public b10 = 0x68656c6c6f776f726c64; //helloworld bytes public bs10 = new bytes(b10.length); //将固定长度数组的值赋值给不定长度数组 function fixedByteToBytes() public &#123; //bs10 = b10; for (uint256 i = 0; i &lt; b10.length; i++) &#123; bs10[i] = b10[i]; &#125; &#125; //将bytes转成string string public str1; function bytesToString() public &#123; fixedByteToBytes(); str1 = string(bs10); &#125; //将string转成bytes bytes public bs20; function stringToBytes() public &#123; bytesToString(); bs20 = bytes(str1); &#125;&#125; 自定义定长数组12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849pragma solidity ^0.4.24;contract Test &#123; //Type[Len] name uint256[10] public numbers = [1,2,3,4,5,6,7,8,9, 10]; uint256 public sum; // - 类型T，长度K的数组定义为T[K]，例如：uint [5] numbers, byte [10] names; // - 内容可变 // - 长度不可变，不支持push // - 支持length方法 function total() public returns(uint256) &#123; for (uint256 i = 0; i &lt; numbers.length; i++) &#123; sum += numbers[i]; &#125; return sum; &#125; function setLen() public &#123; //numbers.length = 10; &#125; function changeValue(uint256 i , uint256 value) public &#123; numbers[i] = value; &#125; //++++++++++++++++++++++++++++++++++ bytes10 public helloworldFixed = 0x68656c6c6f776f726c64; byte[10] public helloworldDynamic = [byte(0x68), 0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x6f, 0x72, 0x6c, 0x64]; bytes public b10; function setToBytes() public returns (string)&#123; for (uint256 i=0; i&lt; helloworldDynamic.length; i++) &#123; byte b1 = helloworldDynamic[i]; b10.push(b1); &#125; return string(b10); &#125;&#125; 自定义不定长数组1234567891011121314151617181920212223242526272829303132333435363738pragma solidity ^0.4.24;contract Test &#123; //第一种创建方式，直接赋值 uint8[] numbers = [1,2,3,4,5,6,7,8,9,10]; function pushData(uint8 num) public &#123; numbers.push(num); &#125; function getNumbers() public view returns(uint8[]) &#123; return numbers; &#125; //使用new关键字进行创建，赋值给storage变量数组 uint8[] numbers2; function setNumbers2() public &#123; numbers2 = new uint8[](7); numbers2.length = 20; numbers2.push(10); &#125; function getNumbers2() public view returns(uint8[]) &#123; return numbers2; &#125; function setNumbers3() public &#123; //使用new创建的memory类型数组，无法改变长度 //uint8[] memory numbers3 = new uint8[](7); uint8[] memory numbers3; //numbers3.push(10); &#125;&#125; 结构体123456789101112131415161718192021222324252627282930313233343536pragma solidity ^0.4.24;//pragma experimental ABIEncoderV2;contract Test &#123; //定义结构之后无分号，与枚举一致 struct Student &#123; string name; uint age; uint score; string sex; &#125; Student[] public Students; //两种赋值方式 Student public stu1 = Student(&quot;lily&quot;, 18, 90, &quot;girl&quot;); Student public stu2 = Student(&#123;name:&quot;Jim&quot;, age:20, score:80, sex:&quot;boy&quot;&#125;); function assign() public &#123; Students.push(stu1); Students.push(stu2); stu1.name = &quot;Lily&quot;; &#125; // function returnStudent() public view returns(Student) &#123; // return stu1; // &#125; //使用圆括号包裹起来的类型叫做元组“tuple” //特性：1. 不可修改，2.可以容纳不同类型的数据 function returnStudent() public view returns(string, uint, uint, string) &#123; return (stu1.name, stu1.age, stu1.score, stu1.sex); &#125;&#125; mapping 相同的key对应的值会被覆盖 所有key都有值，不会抛异常，如果没有设置过某个key，会返回默认值 bool ： false int：0 string ： “” 123456789101112131415161718192021222324252627282930313233343536373839404142pragma solidity ^0.4.20;contract Test &#123; //id -&gt; name mapping(uint =&gt; string) public id_names; //构造函数： //1. 对象在创建的时候，自动执行的函数，完成对象的初始化工作 //2. 构造函数仅执行一次 // function Test() public &#123; // &#125; constructor() public&#123; id_names[1] = &quot;lily&quot;; id_names[2] = &quot;Jim&quot;; id_names[3] = &quot;Lily&quot;; id_names[3] = &quot;Tom&quot;; &#125; function getNameById(uint id) public returns (string)&#123; //加上storage如何赋值？ string memory name = id_names[id]; return name; &#125; function setNameById(uint id) public returns (string)&#123; // mapping(uint =&gt; string) memory id_name = id_names; // var ids = id_names; id_names[id] = &quot;Hello&quot;; &#125; // function getMapLength() public returns (uint)&#123; // return id_names.length; // &#125; &#125;","categories":[{"name":"Blockchain","slug":"Blockchain","permalink":"http://www.zzugo.ayxyj.cn/categories/Blockchain/"},{"name":"Solidity","slug":"Blockchain/Solidity","permalink":"http://www.zzugo.ayxyj.cn/categories/Blockchain/Solidity/"}],"tags":[{"name":"Blockchain","slug":"Blockchain","permalink":"http://www.zzugo.ayxyj.cn/tags/Blockchain/"},{"name":"Solidity","slug":"Solidity","permalink":"http://www.zzugo.ayxyj.cn/tags/Solidity/"}]},{"title":"IPFS - 01 - 搭建","slug":"IPFS","date":"2020-11-15T01:56:11.000Z","updated":"2020-11-15T10:15:08.745Z","comments":true,"path":"2020/11/15/IPFS/","link":"","permalink":"http://www.zzugo.ayxyj.cn/2020/11/15/IPFS/","excerpt":"","text":"一、安装IPFS&gt; * 1.下载Centos或WIndows的安装包 2.上传并安装IPFS 3.解压并安装 12sh install.sh 二、测试IPFS123ipfs daemon #启动ipfs服务 加入IPFS网络ipfs 123456ipfs init ll -a ~/ //可以看到家目录下创建一个 .ipfs 文件夹ipfs cat /ipfs/QmQPeNsJPyVWPFDVHb77w8G42Fvo15z4bG2X8D2GhfbSXc/readme //可以看到IPFS几个模块 12ipfs id 可以通过快速开始学习IPFS的基本操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115[root@zzuxyj7 .ipfs]# ipfs cat /ipfs/QmQPeNsJPyVWPFDVHb77w8G42Fvo15z4bG2X8D2GhfbSXc/quick-start# 0.1 - Quick StartThis is a set of short examples with minimal explanation. It is meant asa &quot;quick start&quot;.Add a file to ipfs: echo &quot;hello world&quot; &gt;hello ipfs add helloView it: ipfs cat &lt;the-hash-you-got-here&gt;Try a directory: mkdir foo mkdir foo/bar echo &quot;baz&quot; &gt; foo/baz echo &quot;baz&quot; &gt; foo/bar/baz ipfs add -r fooView things: ipfs ls &lt;the-hash-here&gt; ipfs ls &lt;the-hash-here&gt;/bar ipfs cat &lt;the-hash-here&gt;/baz ipfs cat &lt;the-hash-here&gt;/bar/baz ipfs cat &lt;the-hash-here&gt;/bar ipfs ls &lt;the-hash-here&gt;/bazReferences: ipfs refs &lt;the-hash-here&gt; ipfs refs -r &lt;the-hash-here&gt; ipfs refs --helpGet: ipfs get &lt;the-hash-here&gt; -o foo2 diff foo foo2Objects: ipfs object get &lt;the-hash-here&gt; ipfs object get &lt;the-hash-here&gt;/foo2 ipfs object --helpPin + GC: ipfs pin add &lt;the-hash-here&gt; ipfs repo gc ipfs ls &lt;the-hash-here&gt; ipfs pin rm &lt;the-hash-here&gt; ipfs repo gcDaemon: ipfs daemon (in another terminal) ipfs idNetwork: (must be online) ipfs swarm peers ipfs id ipfs cat &lt;hash-of-remote-object&gt;Mount: (warning: fuse is finicky!) ipfs mount cd /ipfs/&lt;the-hash-here&gt; lsTool: ipfs version ipfs update ipfs commands ipfs config --help open http://localhost:5001/webuiBrowse: WebUI: http://localhost:5001/webui video: http://localhost:8080/ipfs/QmVc6zuAneKJzicnJpfrqCH9gSy6bz54JhcypfJYhGUFQu/play#/ipfs/QmTKZgRNwDNZwHtJSjCp6r5FYefzpULfy37JvMt9DwvXse images: http://localhost:8080/ipfs/QmZpc3HvfjEXvLWGQPWbHk3AjD5j8NEN4gmFN8Jmrd5g83/cs markdown renderer app: http://localhost:8080/ipfs/QmX7M9CiYXjVeFnkfVGf3y5ixTZ2ACeSGyL1vBJY1HvQPp/mdown","categories":[{"name":"BlockChain","slug":"BlockChain","permalink":"http://www.zzugo.ayxyj.cn/categories/BlockChain/"},{"name":"IPFS","slug":"BlockChain/IPFS","permalink":"http://www.zzugo.ayxyj.cn/categories/BlockChain/IPFS/"}],"tags":[{"name":"BlockChain","slug":"BlockChain","permalink":"http://www.zzugo.ayxyj.cn/tags/BlockChain/"},{"name":"IPFS","slug":"IPFS","permalink":"http://www.zzugo.ayxyj.cn/tags/IPFS/"}]},{"title":"Geth_搭建私有链","slug":"Geth_note","date":"2020-11-14T03:32:14.000Z","updated":"2020-11-15T10:12:46.000Z","comments":true,"path":"2020/11/14/Geth_note/","link":"","permalink":"http://www.zzugo.ayxyj.cn/2020/11/14/Geth_note/","excerpt":"","text":"MetaMask_pass:spot raccoon network sweet feel song knee put just uncover news audit Geth客户端：Geth_download 初始化创世快12D:\\gethData&gt;geth --datadir . init genesis.json此时在testGeth目录下会生成data目录，data目录又包含geth和keystore目录，geth目录存储区块数据，keystore目录则保存账户信息。 启动geth并开启远程RPC然后log输出到output.log里面1234D:\\gethData&gt;geth --datadir . --networkid 15 --rpc console 2&gt; ouput.logD:\\gethData&gt;geth --datadir data --networkid 123 --nodiscover console --networkid 123参数表示区块链网络ID标识，--nodiscover参数表示节点私有，console参数表示进入geth控制台。 连接测试网进入控制台，此时我们已经进入geth测试网的交互式控制台，窗口也显示「Welcome to the Geth JavaScript console」成功提示！ 发送一比交易：1personal.sendTransaction(&#123;from: &quot;0xaC58C330aC8fF04fF828684d3FFABEFE987de7cb&quot; , to: eth.accounts[0] , value: web3.toWei(100 , &quot;ether&quot;)&#125;) 查询账户余额且以ether方式显示1web3.fromWei(eth.getBalance(&quot;0xaC58C330aC8fF04fF828684d3FFABEFE987de7cb&quot;)) 查询账户列表 输入指令：123eth.accounts- 输出结果：[]- 含义：意思是无账户地址，因为我们什么也没做，所以当然是不会凭空出现账户了。 创建新账户 输入指令：personal.newAccount(&quot;123&quot;) 输出结果：hash 含义：表明账户新建成功，返回账户地址，123为账户密码。此时我们再次查询账户列表会发现已有刚创建的地址了。 查询账户余额 输入指令：eth.getBalance(eth.accounts[0]) 输出结果：0 含义：表明这个账户的余额是0。 启动或停止挖矿 输入指令： 123miner.start();admin.sleepBlocks(1);miner.stop() 输入指令： 1eth.getBalance(eth.accounts[0])#查询余额 1234567891011121314151617181920212223Geth Console 是一个交互式的 JavaScript 执行环境， 里面内置了一些用来操作以太坊的 JavaScript对象， 我们可以直接调用这些对象来获取区块链上的相关信息。这些对象主要包括：eth： 主要包含对区块链进行访问和交互相关的方法；net： 主要包含查看 p2p 网络状态的方法；admin： 主要包含与管理节点相关的方法；miner： 主要包含挖矿相关的一些方法；personal：包含账户管理的方法；txpool：包含查看交易内存池的方法；web3：包含以上所有对象，还包含一些通用方法。常用命令有：personal.newAccount()：创建账户；personal.unlockAccount()：解锁账户；eth.accounts： 列出系统中的账户；eth.getBalance()：查看账户余额，返回值的单位是 Wei；eth.blockNumber：列出当前区块高度；eth.getTransaction()：获取交易信息；eth.getBlock()：获取区块信息；miner.start()：开始挖矿；miner.stop()：停止挖矿；web3.fromWei()： Wei 换算成以太币；web3.toWei()：以太币换算成 Wei；txpool.status：交易池中的状态； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179 admin &gt; admin &#123; datadir: &quot;D:\\\\gethData&quot;, nodeInfo: &#123; enode: &quot;enode://fac072814049255eb2f4c8c2c381183d87ee519d93600852cdcabd7dc3d9224d916be319bb2bfed89430112225f338d9dc15ea818f89cd242e46a05dd6bd63a7@192.168.136.117:30303&quot;, enr: &quot;enr:-Je4QFYrz1dcrKYsGSKlFZARRs4T6pki558pyHzIb1294oLWfgVCCLANovQUjqPjxi7jqfHjS_Elg3BI97K7JyFtbVACg2V0aMfGhMmaRmeAgmlkgnY0gmlwhMCoiHWJc2VjcDI1NmsxoQP6wHKBQEklXrL0yMLDgRg9h-5RnZNgCFLNyr19w9kiTYN0Y3CCdl-DdWRwgnZf&quot;, id: &quot;8a2d0a9309f63565292f84e6286532af5abc27df6abfb93f49c0d2d077b9666d&quot;, ip: &quot;192.168.136.117&quot;, listenAddr: &quot;[::]:30303&quot;, name: &quot;Geth/v1.9.23-stable-8c2f2715/windows-amd64/go1.15&quot;, ports: &#123; discovery: 30303, listener: 30303 &#125;, protocols: &#123; eth: &#123; config: &#123;...&#125;, difficulty: 2000, genesis: &quot;0xdc9866ac4601761e6b960e690eb144c03dd48e7125c99e14ecf0a0af5d739224&quot;, head: &quot;0xdc9866ac4601761e6b960e690eb144c03dd48e7125c99e14ecf0a0af5d739224&quot;, network: 16 &#125; &#125; &#125;, peers: [&#123; caps: [&quot;eth/63&quot;], enode: &quot;enode://8192f9e5cfa8fb73e914c39e830211ab2b98d6180df1cf009c1b1c9ddad3bb6d09d986db5ee125f4bb59c226014e72975f170c734774cc389ccb6e6f73fcce34@174.138.19.97:1234&quot;, id: &quot;f227374bcd5f39fff43a333f04cbe43393f5db0baf5eb4ebddd9c8a9ae6fdfbe&quot;, name: &quot;Geth/v1.0.0-stable-7e368c8e/linux-amd64/go1.12.10&quot;, network: &#123; inbound: false, localAddress: &quot;192.168.1.118:50638&quot;, remoteAddress: &quot;174.138.19.97:1234&quot;, static: false, trusted: false &#125;, protocols: &#123; eth: &quot;handshake&quot; &#125; &#125;, &#123; caps: [&quot;eth/63&quot;, &quot;eth/64&quot;, &quot;eth/65&quot;], enode: &quot;enode://5928e6c7a1b9c90014b5b5ef5fbd305636b477f2e35b5c608ed7fae82e0ea3295be2c716ec50de640e5b0665c44f652cde5c9f3a6e4bcf134657a6944cd91d39@149.5.29.162:30303&quot;, id: &quot;f24d4969e9e4f171b36d962f15ea1bc25b037731a99eee25887b02d1437d09ac&quot;, name: &quot;Pirl/v1.9.12-v7-masternode-premium-lion-ea07aebf-20200407/linux-amd64/go1.13.6&quot;, network: &#123; inbound: false, localAddress: &quot;192.168.1.118:50661&quot;, remoteAddress: &quot;149.5.29.162:30303&quot;, static: false, trusted: false &#125;, protocols: &#123; eth: &quot;handshake&quot; &#125; &#125;], addPeer: function(), addTrustedPeer: function(), clearHistory: function(), exportChain: function(), getDatadir: function(callback), getNodeInfo: function(callback), getPeers: function(callback), importChain: function(), removePeer: function(), removeTrustedPeer: function(), sleep: function(), sleepBlocks: function(), startRPC: function(), startWS: function(), stopRPC: function(), stopWS: function() &#125;personal &gt; personal &#123; listAccounts: [&quot;0xc59256c9f92d19e877d4a9931652ccbcd1260076&quot;], listWallets: [&#123; accounts: [&#123;...&#125;], status: &quot;Locked&quot;, url: &quot;keystore://D:\\\\gethData\\\\keystore\\\\UTC--2020-11-10T00-51-59.108912200Z--c59256c9f92d19e877d4a9931652ccbcd1260076&quot; &#125;], deriveAccount: function(), ecRecover: function(), getListAccounts: function(callback), getListWallets: function(callback), importRawKey: function(), initializeWallet: function(), lockAccount: function(), newAccount: function(), openWallet: function(), sendTransaction: function(), sign: function(), signTransaction: function(), unlockAccount: function(), unpair: function() &#125;miner &gt; miner &#123; getHashrate: function(), setEtherbase: function(), setExtra: function(), setGasPrice: function(), setRecommitInterval: function(), start: function(), stop: function() &#125;eth &gt; eth &#123; accounts: [&quot;0xc59256c9f92d19e877d4a9931652ccbcd1260076&quot;], blockNumber: 0, coinbase: &quot;0xc59256c9f92d19e877d4a9931652ccbcd1260076&quot;, compile: &#123; lll: function(), serpent: function(), solidity: function() &#125;, defaultAccount: undefined, defaultBlock: &quot;latest&quot;, gasPrice: 1000000000, hashrate: 0, mining: false, pendingTransactions: [], protocolVersion: &quot;0x41&quot;, syncing: false, call: function(), chainId: function(), contract: function(abi), estimateGas: function(), fillTransaction: function(), filter: function(options, callback, filterCreationErrorCallback), getAccounts: function(callback), getBalance: function(), getBlock: function(), getBlockByHash: function(), getBlockByNumber: function(), getBlockNumber: function(callback), getBlockTransactionCount: function(), getBlockUncleCount: function(), getCode: function(), getCoinbase: function(callback), getCompilers: function(), getGasPrice: function(callback), getHashrate: function(callback), getHeaderByHash: function(), getHeaderByNumber: function(), getMining: function(callback), getPendingTransactions: function(callback), getProof: function(), getProtocolVersion: function(callback), getRawTransaction: function(), getRawTransactionFromBlock: function(), getStorageAt: function(), getSyncing: function(callback), getTransaction: function(), getTransactionCount: function(), getTransactionFromBlock: function(), getTransactionReceipt: function(), getUncle: function(), getWork: function(), iban: function(iban), icapNamereg: function(), isSyncing: function(callback), namereg: function(), resend: function(), sendIBANTransaction: function(), sendRawTransaction: function(), sendTransaction: function(), sign: function(), signTransaction: function(), submitTransaction: function(), submitWork: function() &#125;","categories":[{"name":"BlockChain","slug":"BlockChain","permalink":"http://www.zzugo.ayxyj.cn/categories/BlockChain/"},{"name":"Geth","slug":"BlockChain/Geth","permalink":"http://www.zzugo.ayxyj.cn/categories/BlockChain/Geth/"}],"tags":[{"name":"BlockChain","slug":"BlockChain","permalink":"http://www.zzugo.ayxyj.cn/tags/BlockChain/"},{"name":"Geth","slug":"Geth","permalink":"http://www.zzugo.ayxyj.cn/tags/Geth/"}]},{"title":"Hexo_本地图片如何上传到Github","slug":"Hexo-本地图片-md","date":"2020-11-13T09:49:25.000Z","updated":"2020-11-13T11:02:00.121Z","comments":true,"path":"2020/11/13/Hexo-本地图片-md/","link":"","permalink":"http://www.zzugo.ayxyj.cn/2020/11/13/Hexo-%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87-md/","excerpt":"","text":"第一步 首先进行配置文件的修改， _config.yml(不是主题配置文件)1post_asset_folder: true 第二步1npm install hexo-asset-image --save 第三步 通过命令，创建一篇新的文章时候，自动在source/_post/新建对应文件名称的文件夹（为了避免有时候文章中并没有图片，可以手动创建md文件，需要图片在创建文件夹即可）1hexo new test.md 进入source/_post/下即可看到对应创建的文件和文件夹第四步123hexo clean #清除hexo ge #生成静态资源 ， 此时可以通过输出信息看到对应的图片名称信息，基本就完成了hexo s #本地查看是否生效 注意 在md文件中，图片的路径可以写一下两种方式都可以load到图片的路径12![test1](./1.png)![test1](./test/2.png)","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.zzugo.ayxyj.cn/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.zzugo.ayxyj.cn/tags/Hexo/"}]},{"title":"Git基本用法","slug":"git","date":"2020-11-13T09:49:25.000Z","updated":"2020-11-15T11:10:19.000Z","comments":true,"path":"2020/11/13/git/","link":"","permalink":"http://www.zzugo.ayxyj.cn/2020/11/13/git/","excerpt":"","text":"Git 入门 默认linux自带Git , 可以进行更新。 1yum install git -y #安装git 1git config 12345678910111213141516171819202122232425262728293031323334[root@zzuxyj7 ~]# git config 用法：git config [选项]配置文件位置 --global 使用全局配置文件 --system 使用系统级配置文件 --local 使用版本库级配置文件 -f, --file &lt;文件&gt; 使用指定的配置文件 --blob &lt;blob-id&gt; read config from given blob object操作 --get 获取值：name [value-regex] --get-all 获得所有的值：key [value-regex] --get-regexp 根据正则表达式获得值：name-regex [value-regex] --replace-all 替换所有匹配的变量：name value [value_regex] --add 添加一个新的变量：name value --unset 删除一个变量：name [value-regex] --unset-all 删除所有匹配项：name [value-regex] --rename-section 重命名小节：old-name new-name --remove-section 删除一个小节：name -l, --list 列出所有 -e, --edit 打开一个编辑器 --get-color &lt;slot&gt; 找到配置的颜色：[默认] --get-colorbool &lt;slot&gt; 找到颜色设置：[stdout-is-tty]类型 --bool 值是 &quot;true&quot; 或 &quot;false&quot; --int 值是十进制数 --bool-or-int 值是 --bool or --int --path 值是一个路径（文件或目录名）其它 -z, --null 终止值是NUL字节 --includes 查询时参照 include 指令递归查找 第一步 首先配置Git的本地用户信息，用于提交到本地仓库认证，否则不予提交 配置是哪个用户使用git 12345[root@zzuxyj7 ~]# git config --global user.email &quot;aayxyj@163.com&quot;[root@zzuxyj7 ~]# git config --global user.name &quot;zzuxyj&quot;[root@zzuxyj7 ~]# git config --global color.ui true //高亮 12345678910[root@zzuxyj7 ~]# git config --listuser.name=zzuxyjuser.email=aayxyj@163.comcolor.ui=true[root@zzuxyj7 ~]# cat .gitconfig [user] name = zzuxyj email = aayxyj@163.com[color] ui = true 第二步 创建文件夹并进行初始化，该目录即为本地仓库 创建本地仓库123mkdir gitdata #创建目录cd gitdata #进入目录git init #初始化仓库 初始化空的 Git 版本库于 /root/gitdata/.git/ 本地仓库信息12345678910隐藏文件介绍︰branches # 分支目录config# 定义项目特有的配置选项description# 仅供git web程序使用HEAD #指示当前的分支hooks # 包含git钩子文件info #包含一个全局排除文件(exclude文件)objects # 存放所有数据内容，有info和pack两个子文件夹refrs # 存放指向数据(分支)的提交对象的指针index #保存暂存区信息，在执行git init的时候，这个文件还没有 查看初始的git版本库的结构123456789101112131415161718192021222324[root@zzuxyj7 gitdata]# tree .git/.git/├── branches├── config├── description├── HEAD├── hooks│ ├── applypatch-msg.sample│ ├── commit-msg.sample│ ├── post-update.sample│ ├── pre-applypatch.sample│ ├── pre-commit.sample│ ├── prepare-commit-msg.sample│ ├── pre-push.sample│ ├── pre-rebase.sample│ └── update.sample├── info│ └── exclude├── objects│ ├── info│ └── pack└── refs ├── heads └── tags 第三步 开始进行代码或文件的CURD操作 提交为空，但是存在尚未跟踪的文件（使用 “git add” 建立跟踪）12[root@zzuxyj7 gitdata]# git add 1.go #跟踪[root@zzuxyj7 gitdata]# git status #查看git仓库的状态，可以看到跟踪的文件 提交跟踪文件后，需要删除时候123[root@zzuxyj7 gitdata]# git rm 1.go #删除跟踪rm &#x27;1.go&#x27;[root@zzuxyj7 gitdata]# git status #查看git仓库的状态，文件已经被删除 建立文件跟踪后，如果需要提交到本地仓库还是需要进行commit提交才可以到本地仓库1234[root@zzuxyj7 gitdata]# git commit -m &quot;Test&quot;[master（根提交） b58f049] Test 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 1.go 注 ：常用的git命令12345678910111213141516171819202122232425262728293031323334353637383940411.git init#初始化仓库把一个目录初始化为版本仓库〈可以是空的目录也可以是带内容的目录)2.git status#查看当前仓库的状态3.git add file#添加文件到暂存区4.git add .或者git add * #添加当前所有的文件到暂存区5.git rm --cached#撤出暂存区6.git rm -f#同时删除工作目录和暂存区的文件7.git commit -m#从缓存区提交到本地仓库8.git mv old-filename new-filename#直接更改文件名称更改完直接commit提交即可9.git diff#默认比对工作目录和暂存区有什么不同10.git diff --cached #比对暂存区域和本地仓库11.#如果某个文件已经被仓库管理,如果在更改此文件直接需要一条命令提交即可 git commit -am &quot;add newfile&quot;12.git log#查看历史提交过的信息 -p #查看具体的改动 -1#查看最近一次13.git reset --hard 295e997 #回滚数据到某一个提交14.git log --oneline --decorate#查看当前指针的指向15.git log --reflog #查看所有镜像15.git branch#查看分支 * 号在那就在那个分支上16.git branch testing#创建一个测试分支17.git checkout testing#切换到测试分支18.git checkout -b testing#创建并切换到testing分支19.git tag#打标签 -d删除标签 git tag -d v1.0 #删除标签 git tag -a &quot;v2.0&quot; -m &quot;xxx&quot; #打标签 git show v1.0 #查看版本信息20.git remote add origin git@github.com:ayxyj/ayxyj.github.io.git //添加远程仓库 git remote #查看远程仓库21.git clone url 标签也是指向了一次commit提交，是一个里程碑式的标签，回滚打标签直接加标签号，不需要加唯一字符串不好记 [root@git git_data]# git tag -a v1.0 -m &quot;aaa bbb master tesing version v1.0”# -a指定标签名字 -m指定说明文字 [root@git git_data]# git tagv1.0 [root@git git_data]# git tag -a v2.0 dbead4c -m &quot;add bbb version v2.0&quot; #指定某一次的提交 为标签 [root@git git_data]# git show v1.0 #查看v1.0的信息git show加标签查看 [root@git git_data]# git reset --hard v2.0#直接还原数据到v2.0 最后如何把本地仓库推送到远程仓库步骤： 第一种方式每次手动写远程仓库地址 1.首先先把本地代码提交到本地仓库 123git add . git commit -m &quot;add file !&quot; git commit -am &quot;add file !&quot; 2.其次再把本地仓库的代码提交到远程仓库上 123git remote add gocode git@github.com:ayxyj/ayxyj.github.io.git #添加远程仓库git push -u gocode master #第一次提交到远程仓库的master分支上git push gocode master #之后提交 3.删除本地分支和远程分支 12git branch -d master #删除本地分支、注意删除时候应该切换到其他分支才可以删除分支git push gocode --delete master #删除远程仓库下的mater分支 4.合并本地分支和远程分支 12345678910111213141516171819202122232425基本流程0.查看远程仓库git remote -v1.本地创建一个与新分支并且关联远程分支git checkout -b dev gocode/dev 这时 dev 已经和远程的 gocode/dev 一致了。同上1.查看到远程有一个叫gocode的仓库，我们可以使用如下命令从gocode远程仓库获取最新版本的代码。git fetch origin master:temp上面代码的意思是：从远程的gocode仓库的master分支下载到本地，并新建一个temp分支。2.查看temp分支与本地原有分支的不同git diff temp3. 切换回本地的 master 版本git checkout master 4. 将本地的 dev 合并到 mastergit merge dev 5. 将本地的 master 推到远程git push gocode master 6. 将远程的 dev 版本删除 第二种方式在配置文件中配置远程仓库的地址（需要做ssh认证） 生成ssh公私钥12ssh-keygen -t rsa -C &quot;aayxyj@163.com&quot;cat ~/.ssh/id_rsa.pub #将查看到的公钥在github的个人设置中新建ssh密码填入即可 在配置文件中添加信息1234deploy: type: git repo: 这里填刚记录的github clone仓库地址 branch: master #上传到那个分支上 接下来就可以直接push即可","categories":[{"name":"Git","slug":"Git","permalink":"http://www.zzugo.ayxyj.cn/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://www.zzugo.ayxyj.cn/tags/Git/"}]},{"title":"Sublime 乱码问题及插件安装","slug":"sublime配置","date":"2020-11-13T02:21:29.000Z","updated":"2020-11-13T09:29:28.271Z","comments":true,"path":"2020/11/13/sublime配置/","link":"","permalink":"http://www.zzugo.ayxyj.cn/2020/11/13/sublime%E9%85%8D%E7%BD%AE/","excerpt":"","text":"sublime 解决中文乱码问题1.通过快捷键 ctrl + ~ 进入命令行，并输入以下命令然后回车1import urllib.request,os,hashlib; h = &#x27;7183a2d3e96f11eeadd761d777e62404e330c659d4bb41d3bdf022e94cab3cd0&#x27;; pf = &#x27;Package Control.sublime-package&#x27;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &#x27;http://sublime.wbond.net/&#x27; + pf.replace(&#x27; &#x27;, &#x27;%20&#x27;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&#x27;Error validating download (got %s instead of %s), please try manual install&#x27; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &#x27;wb&#x27; ).write(by) 这是由于网络访问网站http://packagecontrol.io/无法访问成功导致的，所以确保能够访问该网址时才能继续安装，这里我直接通过科学上网的方式就可以访问了，但是又出现了下面的问题： 根据报错信息将该命令中的str1 字符串换成str2再重试即可发现成功 2.安装ConvertToUTF8。 通过快捷键 Ctrl + shift + P，然后在弹出的输入框输入 install，选择Package Control：install Package回车 在出现的插件命令行搜索ConvertToUTF8，选中回车进行插件安装 重启Sublime Text 3后再次打开之前中文乱码的文件发现，中文能够正常显示 sublime 主题和字体 通过快捷键 Ctrl + shift + P ，然后在弹出的输入框输入 install，选择Package Control：install Package回车 在出现的插件命令行搜索Themes：ayu/edge Font：Consoles","categories":[{"name":"Sublime","slug":"Sublime","permalink":"http://www.zzugo.ayxyj.cn/categories/Sublime/"}],"tags":[{"name":"Sublime","slug":"Sublime","permalink":"http://www.zzugo.ayxyj.cn/tags/Sublime/"}]},{"title":"FISCO BCOS - 01 - 入门","slug":"fb","date":"2020-11-11T06:38:59.000Z","updated":"2020-11-13T10:09:18.462Z","comments":true,"path":"2020/11/11/fb/","link":"","permalink":"http://www.zzugo.ayxyj.cn/2020/11/11/fb/","excerpt":"","text":"安装本章介绍FISCO BCOS所需的必要安装和配置。本章通过在单机上部署一条4节点的FISCO BCOS联盟链，帮助用户掌握FISCO BCOS部署流程。请根据这里使用支持的硬件和平台操作。 安装FISCOBCOS：https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/installation.html 国密：https://fisco-bcos-documentation.readthedocs.io/zh_CN/latest/docs/manual/account.html 单群组**FISCO BCOS**联盟链的搭建 准备环境安装centos依赖12sudo yum install -y openssl openssl-devel 12cd ~ &amp;&amp; mkdir -p fisco &amp;&amp; cd fisco ​ 下载build_chain.sh脚本 123curl -#LO https://github.com/FISCO-BCOS/FISCO-BCOS/releases/download/v2.6.0/build_chain.sh &amp;&amp; chmod u+x build_chain.sh 搭建单群组**4**节点联盟链在fisco目录下执行下面的指令，生成一条单群组4节点的FISCO链。 请确保机器的3030030303，2020020203，8545~8548端口没有被占用。 12345678910**注解**&gt; 国密版本请执行 bash build_chain.sh -l 127.0.0.1:4 -p 30300,20200,8545 -g -G&gt; 其中-g表示生成国密配置，-G表示使用国密SSL连接&gt; web3sdk已经支持国密SSL，如果使用web3sdk建议带上-G选项使用国密SSLbash build_chain.sh -l 127.0.0.1:4 -p 30300,20200,8545 注解 其中-p选项指定起始端口，分别是p2p_port,channel_port,jsonrpc_port 出于安全性和易用性考虑，v2.3.0版本最新配置将listen_ip拆分成jsonrpc_listen_ip和channel_listen_ip，但仍保留对listen_ip的解析功能，详细请参考 这里 为便于开发和体验，channel_listen_ip参考配置是 0.0.0.0 ，出于安全考虑，请根据实际业务网络情况，修改为安全的监听地址，如：内网IP或特定的外网IP 命令执行成功会输出All completed。如果执行出错，请检查nodes/build.log文件中的错误信息。 启动**FISCO BCOS**链 启动所有节点 12bash nodes/127.0.0.1/start_all.sh 启动成功会输出类似下面内容的响应。否则请使用netstat -an | grep tcp检查机器的3030030303，2020020203，8545~8548端口是否被占用。 检查进程 检查进程是否启动 正常情况会有类似下面的输出； 如果进程数不为4，则进程没有启动（一般是端口被占用导致的） 1ps -ef | grep -v grep | grep fisco-bcos 检查日志输出 如下，查看节点node0链接的节点数 1tail -f nodes/127.0.0.1/node0/log/log* | grep connected 正常情况会不停地输出链接信息，从输出可以看出node0与另外3个节点有链接。 执行下面指令，检查是否在共识 1tail -f nodes/127.0.0.1/node0/log/log* | grep +++ 正常情况会不停输出++++Generating seal，表示共识正常。 配置及使用控制台 重要 控制台1.x 系列基于 Web3SDK 实现，控制台2.6之后 基于 Java SDK 实现，最新版本控制台基于 Java SDK 实现 2.6及其以上版本控制台使用文档请 参考这里 ，1.x版本控制台使用文档请 参考这里 可通过命令 ./start.sh –version 查看当前控制台版本 基于 Web3SDK 开发应用时将 solidity 代码转换为 java 代码时，必须使用 1.x 版本控制台，具体请参考 这里 在控制台链接FISCO BCOS节点，实现查询区块链状态、部署调用合约等功能，能够快速获取到所需要的信息。2.6版本控制台指令详细介绍参考这里，1.x版本控制台指令详细介绍参考这里。 准备依赖 安装java #centos系统安装java 1sudo yum install -y java java-devel 获取控制台并回到fisco目录 1cd ~/fisco &amp;&amp; curl -#LO https://github.com/FISCO-BCOS/console/releases/download/v2.6.1/download_console.sh &amp;&amp; bash download_console.sh 注解 如果因为网络问题导致长时间无法下载，请尝试 cd ~/fisco &amp;&amp; curl -#LO https://gitee.com/FISCO-BCOS/console/raw/master/tools/download_console.sh 拷贝控制台配置文件 若节点未采用默认端口，请将文件中的20200替换成节点对应的channel端口。 # 最新版本控制台使用如下命令拷贝配置文件 1cp -n console/conf/config-example.toml console/conf/config.toml 配置控制台证书 注解 使用**1.x**版本控制台时： 1234搭建国密版时，如果使用国密SSL请执行 cp nodes/127.0.0.1/sdk/gm/* console/conf/搭建国密版时，请修改 applicationContext.xml 中 encryptType 修改为1 1cp -r nodes/127.0.0.1/sdk/* console/conf/ 启动控制台 启动 1cd ~/fisco/console &amp;&amp; bash start.sh 输出下述信息表明启动成功 否则请检查conf/config.toml中节点端口配置是否正确 使用控制台获取信息 # 获取客户端版本 1[group:1]&gt; getNodeVersion # 获取节点链接信息 1[group:1]&gt; getPeers 部署及调用**HelloWorld**合约 HelloWorld合约提供两个接口，分别是get()和set()，用于获取/设置合约变量name。合约内容如下: 1234567891011121314151617181920pragma solidity ^0.4.24;contract HelloWorld &#123; string name; function HelloWorld() &#123; name &#x3D; &quot;Hello, World!&quot;; &#125; function get()constant returns(string) &#123; return name; &#125; function set(string n) &#123; name &#x3D; n; &#125;&#125; 部署**HelloWorld**合约 为了方便用户快速体验，HelloWorld合约已经内置于控制台中，位于控制台目录下contracts/solidity/HelloWorld.sol，参考下面命令部署即可。 # 在控制台输入以下指令 部署成功则返回合约地址 1[group:1]&gt; deploy HelloWorld 调用**HelloWorld**合约 # 查看当前块高 1[group:1]&gt; getBlockNumber # 调用get接口获取name变量 此处的合约地址是deploy指令返回的地址 1[group:1]&gt; call HelloWorld 0xb3c223fc0bf6646959f254ac4e4a7e355b50a344 get # 查看当前块高，块高不变，因为get接口不更改账本状态 1[group:1]&gt; getBlockNumber # 调用set设置**name 1[group:1]&gt; call HelloWorld 0xb3c223fc0bf6646959f254ac4e4a7e355b50a344 set &quot;Hello, FISCO BCOS&quot; # 再次查看当前块高，块高增加表示已出块，账本状态已更改 1[group:1]&gt; getBlockNumber # 调用get接口获取name变量，检查设置是否生效 1[group:1]&gt; call HelloWorld 0xb3c223fc0bf6646959f254ac4e4a7e355b50a344 get # 退出控制台 1[group:1]&gt; quit","categories":[{"name":"FISCO BCOS","slug":"FISCO-BCOS","permalink":"http://www.zzugo.ayxyj.cn/categories/FISCO-BCOS/"}],"tags":[{"name":"FISCO BCOS","slug":"FISCO-BCOS","permalink":"http://www.zzugo.ayxyj.cn/tags/FISCO-BCOS/"}]},{"title":"Docker - 01 - 入门啊","slug":"docker","date":"2020-11-01T06:38:59.000Z","updated":"2020-11-13T09:47:59.125Z","comments":true,"path":"2020/11/01/docker/","link":"","permalink":"http://www.zzugo.ayxyj.cn/2020/11/01/docker/","excerpt":"","text":"1. Docker介绍1.1 什么是容器?1.2 容器的前世FreeBASE jail ——&gt; Linux vserverchroot —–&gt; 完整的根文件系统(FHS)标准的namespaces —&gt; UTS Mount IPC PID user networkcgroup —&gt; 资源的分配和监控 通过比较复杂的代码开发的过程,调用以上三项技术实现容器的创建 —-&gt; 管理 —-&gt;销毁 1.3 传统虚拟化技术和容器对比1.4 容器的今生?实现隔离能力!LXC (LinuXContainer)对于原有的常用功能进行了封装,方便我们做容器的生命周期—–&gt; Docker (dotcloud) 1.5 Docker 帮助文档https://docs.docker.com/engine/reference/commandline/cli/?spm=5176.8351553.0.0.248a1991nVGS9m 2. Docker的安装2.0、yum源准备123curl http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;docker-ce&#x2F;linux&#x2F;centos&#x2F;docker-ce.repo -o &#x2F;etc&#x2F;yum.repos.d&#x2F;docker-ce.repowget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;epel.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;epel-7.repocurl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;repo&#x2F;Centos-7.repo 2.1 安装依赖包12yum install -y yum-utils device-mapper-persistent-data lvm2yum list docker-ce.x86_64 --showduplicates | sort -r yum install -y docker-ce 2.2 安装docker-ce123yum install -y --setopt&#x3D;obsoletes&#x3D;0 \\docker-ce-17.03.2.ce-1.el7.centos.x86_64 \\docker-ce-selinux-17.03.2.ce-1.el7.centos.noarch 2.3 启动Docker服务1234systemctl daemon-reloadsystemctl restart dockerdocker versiondocker info 2.4 配置镜像加速12345678910111213141516171819阿里云Docker-hubhttps:&#x2F;&#x2F;cr.console.aliyun.com&#x2F;cn-hangzhou&#x2F;mirrorsmkdir -p &#x2F;etc&#x2F;dockertee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;&#123; &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;uoggbpok.mirror.aliyuncs.com&quot;]&#125;EOFsystemctl daemon-reloadsystemctl restart docker 或者:vim &#x2F;etc&#x2F;docker&#x2F;daemon.json &#123; &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;68rmyzg7.mirror.aliyuncs.com&quot;] &#125; #3. Doocker体系结构 4. Docker的镜像基础管理4.1 获取镜像123456基础镜像拉取docker search centosdocker pull centos:6.9docker pull centos:7.5.1804docker pull docker.io&#x2F;golangdocker pull nginx 4.2 镜像基本查看123456789101112131415[root@docker ~]# docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEcentos 6.8 82f3b5f3c58f 4 months ago 195 MBcentos 6.9 2199b8eb8390 4 months ago 195 MBcentos 7.5.1804 cf49811e3cdb 4 months ago 200 MBcentos 7.6.1810 f1cb7c7d58b7 4 months ago 202 MBoldguo&#x2F;centos_sshd v1.0oldguo&#x2F;centos_sshd v2.0oldguo&#x2F;centos_sshd v3.0标识镜像唯一性的方法:1. REPOSITORY:TAGcentos:7.5.1804 2. IMAGE ID (sha256:64位的号码,默认只截取12位)82f3b5f3c58 [root@docker &#x2F;]# docker image ls --no-trunc 4.3 镜像详细信息查看12[root@docker &#x2F;]# docker image inspect ubuntu:latest[root@docker &#x2F;]# docker image inspect 82f3b5f3c58f 4.4 只查看镜像ID1[root@docker ~]# docker image ls -q 4.5 镜像的导入和导出1234[root@docker ~]# docker image save 3556258649b2 &gt;&#x2F;tmp&#x2F;ubu.tar[root@docker ~]# docker image rm 3556258649b2[root@docker ~]# docker image load -i &#x2F;tmp&#x2F;ubu.tar[root@docker ~]# docker image tag 3556258649b2 oldguo&#x2F;ubu:v1 4.6 镜像的删除12[root@docker ~]# docker image rm -f 3556258649b2[root@docker ~]# docker image rm -f &#96;docker image ls -q&#96; 5. 容器的管理5.1 运行第一个容器5.1.1 交互式的容器:12345678910111213141516[root@docker ~]# docker container run -it 9f38484d220f[root@docker &#x2F;]# docker container ls[root@docker &#x2F;]# docker container lsCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES4d1ef5a6ecfc 9f38484d220f &quot;&#x2F;bin&#x2F;bash&quot; 5 minutes ago Up 5 minutes nervous_alleCONTAINER ID : 容器的唯一号码(自动生成的)NAMES : 容器的名字(可以自动,也可以手工指定)例子: 手工指定容器名启动[root@docker &#x2F;]# docker container run -it --name&#x3D;&quot;oldguo_cent76&quot; 9f38484d220f[root@docker &#x2F;]# docker container ls -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESef45b19d8c7b 9f38484d220f &quot;&#x2F;bin&#x2F;bash&quot; About a minute ago Exited (0) 5 seconds ago oldguo_cent764d1ef5a6ecfc 9f38484d220f &quot;&#x2F;bin&#x2F;bash&quot; 9 minutes ago Up 9 minutes nervous_allenSTATUS : 容器的运行状态 ( Exited , Up) 5.1.2 守护式容器1234[root@docker &#x2F;]# docker run -d --name&#x3D;&quot;oldguo_nginx&quot; nginx:1.14查询容器的详细信息:[root@docker &#x2F;]# docker container inspect oldguo_nginx[root@zzuxyj7 ~]#curl -I 172.17.0.2 5.1.3 容器的应用场景1234交互式的容器: 工具类: 开发,测试,临时性的任务()[root@docker ~]# docker container run -it --name&#x3D;&quot;oldguo_cent76&quot; --rm 9f38484d220f守护式容器: 网络服务[root@docker &#x2F;]# docker run -d -p 8080:80 --name&#x3D;&quot;oldguo_nginx_80&quot; nginx:1.14 5.1.4 容器的启动\\关闭\\连接123456789101112131415161718192021守护式容器的关闭和启动[root@docker &#x2F;]# docker container stop oldguo_nginx_80[root@docker &#x2F;]# docker container start oldguo_nginx_80交互式的容器的关闭和启动[root@docker &#x2F;]# docker container stop nervous_allen[root@docker &#x2F;]# docker container start -i nervous_allen容器的连接方法:[root@docker &#x2F;]# docker container attach nervous_allen子进程的方式登录(在已有工作容器中生成子进程,做登录.可以用于进行容器的调试,退出时也不会影响到当前容器)[root@docker ~]# docker container exec -it nervous_allen &#x2F;bin&#x2F;bash容器的后台及前台运行:1. ctrl + P, Q attach 调用到前台2. 死循环 3. 让程序前台一直允许(夯在前台)制作守护式容器时,常用的方法 5.2 docker容器的网络访问12345678910111213指定映射(docker 会自动添加一条iptables规则来实现端口映射) -p hostPort:containerPort -p ip:hostPort:containerPort -p ip::containerPort(随机端口:32768-60999) -p hostPort:containerPort&#x2F;udp -p 81:80 –p 443:443随机映射 docker run -P 80（随机端口） [root@docker ~]# docker container run -d -p 8080:80 --name&#x3D;&#39;n2&#39; nginx:1.14 *****[root@docker ~]# docker container run -d -p 10.0.0.100:8081:80 --name&#x3D;&#39;n3&#39; nginx:1.14 *****[root@docker ~]# docker container run -d -p 80 --name&#x3D;&#39;n5&#39; nginx:1.14[root@docker ~]# docker container run -d -p 172.16.1.200::80 --name&#x3D;&#39;n6&#39; nginx:1.14 5.3容器的其他管理1234567891011121314docker ps -a -q 等价于:docker container ls -a -q[root@docker ~]# docker top ba9143bcaf74等价于:[root@docker ~]# docker container top ba9143bcaf74查看日志:[root@oldboy docker]# docker logs testxx[root@oldboy docker]# docker logs -tf testxx[root@oldboy docker]# docker logs -t testxx[root@oldboy docker]# docker logs -tf --tail 10 testxx[root@oldboy docker]# docker logs -tf --tail 0 testxx 小结: 镜像类: docker image search pull ls ***** inspect ***** rm **** save load 容器类 docker container run ***** start **** stop **** restart kill attach exec ***** ls ***** top **** logs inspect **** 5.4 docker的数据卷实现持久化存储1234567891011121314151617181920212223242526271. 手工交互数据:[root@docker opt]# docker container cp index.html n1:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;[root@docker opt]# docker container cp n1:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;50x.html .&#x2F;2. Volume实现宿主机和容器的数据共享[root@docker opt]# mkdir -p &#x2F;opt&#x2F;html[root@docker ~]# docker run -d --name&#x3D;&quot;nginx_3&quot; -p 83:80 -v &#x2F;opt&#x2F;html:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html nginx作用: 数据持久化3. 例子: 开启两个nginx容器(90,91),共同挂载一个数据卷,实现静态资源共享4. 数据卷容器:(1)宿主机模拟数据目录mkdir -p &#x2F;opt&#x2F;Volume&#x2F;amkdir -p &#x2F;opt&#x2F;Volume&#x2F;btouch &#x2F;opt&#x2F;Volume&#x2F;a&#x2F;a.txttouch &#x2F;opt&#x2F;Volume&#x2F;b&#x2F;b.txt(2)启动数据卷容器docker run -it --name &quot;nginx_volumes&quot; -v &#x2F;opt&#x2F;Volume&#x2F;a:&#x2F;opt&#x2F;a -v &#x2F;opt&#x2F;Volume&#x2F;b:&#x2F;opt&#x2F;b centos:6.9 &#x2F;bin&#x2F;bashctrl p q(3)使用数据卷容器docker run -d -p 8085:80 --volumes-from nginx_volumes --name &quot;n8085&quot; nginxdocker run -d -p 8086:80 --volumes-from nginx_volumes --name &quot;n8086&quot; nginx作用: 在集中管理集群中,大批量的容器都需要挂载相同的多个数据卷时,可以采用数卷容器进行统一管理 制作本地局域网yum源 安装vsftpd软件 [root@docker ~]# yum install -y vsftpd 启动ftp [root@docker ~]# systemctl enable vsftpd [root@docker ~]# systemctl start vsftpd [root@docker ~]# yum install lftpd [root@docker ~]# lftp 127.0.0.1//测试ftp安装是否成功 上传系统进行到虚拟机 略. 配置yum仓库mkdir -p /var/ftp/centos6.9mkdir -p /var/ftp/centos7.5[root@docker mnt]# mount -o loop /mnt/CentOS-6.9-x86_64-bin-DVD1.iso /var/ftp/centos6.9/ windows验证ftp://10.0.0.100/centos6.9/ cat &gt;/yum.repos.d/ftp_6.repo &lt;&lt;EOF[ftp]name=ftpbasebaseurl=ftp://10.0.0.100/var/www/html/ftpenabled=1gpgcheck=0EOF cat &gt;/yum.repos.d/ftp_7.repo &lt;&lt;EOF[ftp]name=ftpbasebaseurl=ftp://10.0.0.100/centos7.5enabled=1gpgcheck=0EOF 搭建本地的yum仓库，并通过vsftpd 和 httpd 共享该目录123456789101112131415yum install httpd vsftpd lftp -y &#x2F;&#x2F;安装三个服务mount -o loop &#x2F;centos6.5.iso &#x2F;var&#x2F;www&#x2F;html&#x2F;ftp&#x2F;centos6.5 &#x2F;&#x2F;注意路径，挂在对应的iso到对应目录下systemctl start httpd vsftpd &#x2F;&#x2F;启动服务systemctl enable httpd vsftpd &#x2F;&#x2F;开机自启动systemctl disable firewalld &#x2F;&#x2F;关闭防火墙开机自启动systemctl stop firewalld &#x2F;&#x2F;关闭防火墙systemctl status firewalld &#x2F;&#x2F;查看防火墙状态 通过上面的服务搭建以及配置接下来可以进行yum仓库的配置，由于搭建镜像的本地服务中，镜像挂在点有repodata/及其配置文件，此时可以不用配置repomd.xml等，可以省略。若搭建其他需要通过下述命令进行配置 1234yum install createrepo -y &#x2F;&#x2F;安装createrepo ，用于构建repodatacreaterepo &#x2F;var&#x2F;www&#x2F;html&#x2F;ftp &#x2F;&#x2F;此时就会该目录下生成repodata&#x2F; 根据yum仓库的配置文件创建一个本地的repo文件要记得修改vsftpd的默认路径 123local_root=/var/www/htmlchroot_local_user=YESanon_root=/var/www/html 1234567cat &gt;/yum.repos.d/ftp_6.repo &lt;&lt;EOF [ftp]name=ftpbasebaseurl=ftp://192.168.100.4/var/www/html/ftpenabled=1gpgcheck=0EOF 通过浏览器访问测试ftp://192.168.100.4/ http://192.168.100.4/ftp/","categories":[{"name":"Docker","slug":"Docker","permalink":"http://www.zzugo.ayxyj.cn/categories/Docker/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://www.zzugo.ayxyj.cn/tags/Docker/"}]},{"title":"MarkDown语法","slug":"markdown","date":"2019-01-23T13:57:00.000Z","updated":"2020-11-08T07:48:20.252Z","comments":true,"path":"2019/01/23/markdown/","link":"","permalink":"http://www.zzugo.ayxyj.cn/2019/01/23/markdown/","excerpt":"","text":"一、字体加粗 ： ** 粗 ** 斜体 ： * 斜体 * 粗斜 ： *** T *** 删除线： ~~ D ~~ 二、标题# ： 一级标题 ## ： 二级标题 ### ： 三级标题 。。。 以此类推 三、引用&gt; : 引用 &gt;&gt; : 嵌套引用 &gt;&gt;&gt; : 再次嵌套引用 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; n次嵌套 : n次嵌套 四、分割线 * 或者 - 三个或者三个以上即可 * 例如： * --- * *** 五、图片语法： ![img alt](img address &quot;img title&quot;) 注： img alt : 图片下方的文字，如 图1所示 img address ： 图片的绝对路径 ing title : 图片的标题 例： ![AYXYJ](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg &quot;TEST&quot;) 六、超链接语法： [超链接名](超链接地址 &quot;超链接title&quot;) 例： [简书](http://jianshu.com) [AYXYJ](http://ayxyj.cn) 注：MarkDown本身语法不支持超链接在新页面打开，貌似简书做了处理，是可以的，别的平台可能不行。 如果想要在新页面中打开的话可以用html语言的a标签代替。 例： &lt;a href = &quot;超链接地址&quot; target=“_blank”&gt;超链接title&lt;/a&gt; &lt;a href=&quot;https://www.jianshu.com/u/1f5ac0cf6a8b&quot; target=&quot;_blank&quot;&gt;简书&lt;/a&gt; 七、列表语法： -无序列表： - + * 都可以 例： - AYXYJ :注意 - 和 ayxyj有一个空格 1.有序列表： 数字加点 例： 1. AYXYJ :序号和内容之间要有空格 - 列表无序嵌套 - 上下级之间敲三个空格即可 1. 列表有序嵌套 2. 上下级之间敲三个空格即可 八、表格语法： 表头|表头|表头 ---|:---:|---: 内容|内容|内容 注： 第二行分割表头和内容： - 有一个即可，为了对其，多加了几个 - 文字默认局左 - 两边加 ： 表示文字居中 - 右边加 ： 表示文字居右 - 原生的语法两边都要 | 包起来，此处省略 例： 姓名|性别|TAG ---|:---:|---: xyj|male|20 syl|female|20 九、代码语法： - 单行代码： 代码之间用 ` 代码 ` ：反引号 - 代码块 : 代码之间分别用三个反引包起来，且两边反引号独占一行 十、流程图语法： flow st=&gt;start: start op=&gt;operation: my operation cond=&gt;condition: Yes or No? e=&gt;end st-&gt;op-&gt;cond cond(yes)-&gt;e cond(no)-&gt;op &amp; ``` 宝剑锋从磨砺出，梅花香自苦寒来~","categories":[{"name":"Markdown","slug":"Markdown","permalink":"http://www.zzugo.ayxyj.cn/categories/Markdown/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.zzugo.ayxyj.cn/tags/hexo/"}]},{"title":"快速搭建Hexo博客","slug":"快速搭建Hexo博客","date":"2018-11-08T02:38:59.000Z","updated":"2020-11-13T11:02:32.168Z","comments":true,"path":"2018/11/08/快速搭建Hexo博客/","link":"","permalink":"http://www.zzugo.ayxyj.cn/2018/11/08/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 由于我的环境是Linux，所以Linux环境的按着来就好了，Win环境大同小异。Hexo手册一、安装基本环境1. 安装Git Git 是目前比较流行的分布式版本控制系统，我们使用它与github进行交互下载对应版本的的git安装就好，下载地址 git_download，装后打开Git Bash 1git --version #可以查看版本号 2. 安装Node.js Node.js是一个Javascript运行环境，是一个让 JavaScript 运行在服务端的开发平台，我们用来快速生成博客的静态页面，LTS版本为长期支持版，CURRENT版本为最新版，任选一个正常安装即可下载地址Node.js_download。 二、开始本地搭建博客1. 新建本地文件夹 在本地新建一个文件夹用来储存我们的博客，Git Bash进入文件夹下，执行命令：npm install hexo -g 用来安装hexo 2. 搭建本地服务 依次在本地文件夹根目录下执行以下命令初始化并生成服务。 1hexo init # 初始化 1npm isntall # 安装npm依赖包 1hexo generate # 生成静态网页 全部执行成功后浏览器访问http://localhost:4000,如果出现默认的hexo博客，那么我们本地搭建博客就完成了 1hexo server # 生成本地服务 三、本地博客发布到网络上1.创建Github远程仓库 这里我们就要用到github了。有账户的可以略过，没有账户的新建账户，并登录。新建一个仓库，仓库名格式设置为：xxxx.github.io,其他可以不动。 之后我们就可以到如下界面，记录ssh的地址 在更改本地目录下的_config.yml配置文件，最后加上. 1234deploy: type: git repo: 这里填刚记录的ssh地址 branch: master 2. 将Hexo与 Github连接 按照如下格式输入，在本地创建git用户名和邮箱进行并生成ssh密钥123git config --global user.name &quot;yourname&quot;git config --global user.email &quot;youremail&quot;ssh-keygen -t rsa -C &quot;youremail&quot; 接下来我们把生成的id_rsa.pub文件用文本编辑器打开，复制里面的内容绑定到GitHub上，标题随意。 点击新建ssh keys，title随便填，key填写id_rsa.pub的内容即可，应该会要求输入密码测试是否成功 1ssh -T git@github.com #注意这里的地址不用改 提示Are you sure you want to continue connecting (yes/no)?时输入yes 当看到Hi Budtit! You’ve successfully authenticated, but GitHub does not provide shell access.时说明配置成功 3. 部署到github1hexo d 如果报错说not found git 我们执行以下命令：npm install hexo-deployer-git --save安装插件，然后在执行上一步命令第一次部署应该会让登录，浏览yourname.github.io成功显示博客页 上面在配置branch时候我写的Master，可以自己新建分支，专门用于存放blog四、写作并上传第一篇博客1. 写作1hexo new [layout] &lt;title&gt; #创建新文章 创建后会在本地目录生成测试.md文件，用markdown语法编辑文件后保存，建议每次写作后本地部署完成进入http://localhost:4000 查看无误后再上传。hexo server # 本地服务部署 可简写为hexo s 2. 上传依次执行命令，hexo的具体用法请查看官方文档 戳这里 123hexo clean # 清除缓存hexo generate # 生成静态页面 可简写为hexo ghexo deploy # 部署博客 可简写为hexo d 五、解析私人域名 这里就要买域名了，添加两条记录 然后在本地博客目录下的source文件夹下新建名为CNAME的文件，其中写入域名 最后在github库中的setting中的Custom domain下填写购买的域名,save保存。好了，域名配置完成。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.zzugo.ayxyj.cn/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://www.zzugo.ayxyj.cn/tags/Hexo/"},{"name":"博客","slug":"博客","permalink":"http://www.zzugo.ayxyj.cn/tags/%E5%8D%9A%E5%AE%A2/"}]}],"categories":[{"name":"Docker","slug":"Docker","permalink":"http://www.zzugo.ayxyj.cn/categories/Docker/"},{"name":"Registry","slug":"Docker/Registry","permalink":"http://www.zzugo.ayxyj.cn/categories/Docker/Registry/"},{"name":"Portainer","slug":"Docker/Portainer","permalink":"http://www.zzugo.ayxyj.cn/categories/Docker/Portainer/"},{"name":"Blockchain","slug":"Blockchain","permalink":"http://www.zzugo.ayxyj.cn/categories/Blockchain/"},{"name":"Hyperledger Fabric","slug":"Blockchain/Hyperledger-Fabric","permalink":"http://www.zzugo.ayxyj.cn/categories/Blockchain/Hyperledger-Fabric/"},{"name":"Solidity","slug":"Blockchain/Solidity","permalink":"http://www.zzugo.ayxyj.cn/categories/Blockchain/Solidity/"},{"name":"BlockChain","slug":"BlockChain","permalink":"http://www.zzugo.ayxyj.cn/categories/BlockChain/"},{"name":"IPFS","slug":"BlockChain/IPFS","permalink":"http://www.zzugo.ayxyj.cn/categories/BlockChain/IPFS/"},{"name":"Geth","slug":"BlockChain/Geth","permalink":"http://www.zzugo.ayxyj.cn/categories/BlockChain/Geth/"},{"name":"Hexo","slug":"Hexo","permalink":"http://www.zzugo.ayxyj.cn/categories/Hexo/"},{"name":"Git","slug":"Git","permalink":"http://www.zzugo.ayxyj.cn/categories/Git/"},{"name":"Sublime","slug":"Sublime","permalink":"http://www.zzugo.ayxyj.cn/categories/Sublime/"},{"name":"FISCO BCOS","slug":"FISCO-BCOS","permalink":"http://www.zzugo.ayxyj.cn/categories/FISCO-BCOS/"},{"name":"Markdown","slug":"Markdown","permalink":"http://www.zzugo.ayxyj.cn/categories/Markdown/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://www.zzugo.ayxyj.cn/tags/Docker/"},{"name":"Registry","slug":"Registry","permalink":"http://www.zzugo.ayxyj.cn/tags/Registry/"},{"name":"Portainer","slug":"Portainer","permalink":"http://www.zzugo.ayxyj.cn/tags/Portainer/"},{"name":"Blockchain","slug":"Blockchain","permalink":"http://www.zzugo.ayxyj.cn/tags/Blockchain/"},{"name":"Hyperledger Fabric","slug":"Hyperledger-Fabric","permalink":"http://www.zzugo.ayxyj.cn/tags/Hyperledger-Fabric/"},{"name":"Solidity","slug":"Solidity","permalink":"http://www.zzugo.ayxyj.cn/tags/Solidity/"},{"name":"BlockChain","slug":"BlockChain","permalink":"http://www.zzugo.ayxyj.cn/tags/BlockChain/"},{"name":"IPFS","slug":"IPFS","permalink":"http://www.zzugo.ayxyj.cn/tags/IPFS/"},{"name":"Geth","slug":"Geth","permalink":"http://www.zzugo.ayxyj.cn/tags/Geth/"},{"name":"Hexo","slug":"Hexo","permalink":"http://www.zzugo.ayxyj.cn/tags/Hexo/"},{"name":"Git","slug":"Git","permalink":"http://www.zzugo.ayxyj.cn/tags/Git/"},{"name":"Sublime","slug":"Sublime","permalink":"http://www.zzugo.ayxyj.cn/tags/Sublime/"},{"name":"FISCO BCOS","slug":"FISCO-BCOS","permalink":"http://www.zzugo.ayxyj.cn/tags/FISCO-BCOS/"},{"name":"hexo","slug":"hexo","permalink":"http://www.zzugo.ayxyj.cn/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"http://www.zzugo.ayxyj.cn/tags/%E5%8D%9A%E5%AE%A2/"}]}